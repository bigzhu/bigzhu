<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.383259911894">
	<global_window_position top="40" left="-24" height="700" width="1024"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="BIGZHU.20070731151011"><vh>@chapters</vh></v>
<v t="BIGZHU.20070731151203"><vh>@thin d:/bigzhu/python/python_project/sniffer-QQ.py</vh></v>
<v t="BIGZHU.20070731160918" a="E"
expanded="BIGZHU.20070802171013,"><vh>@thin d:/bigzhu/python/python_project/get_cmfu.py</vh></v>
<v t="BIGZHU.20070802223007"><vh>@file D:/BIGZHU/Python/python_project/ikog.py</vh>
<v t="BIGZHU.20070802223007.1"><vh>&lt;&lt; ikog declarations &gt;&gt;</vh></v>
<v t="BIGZHU.20070802223007.2"><vh>safeRawInput</vh></v>
<v t="BIGZHU.20070802223007.3"><vh>compareTodo</vh></v>
<v t="BIGZHU.20070802223007.4"><vh>printError</vh></v>
<v t="BIGZHU.20070802223007.5"><vh>clearScreen</vh></v>
<v t="BIGZHU.20070802223007.6" a="E"><vh>class Xtea</vh>
<v t="BIGZHU.20070802223007.7"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.8"><vh>crypt</vh></v>
<v t="BIGZHU.20070802223007.9"><vh>xtea_encrypt</vh></v>
</v>
<v t="BIGZHU.20070802223007.10"><vh>class WordWrapper</vh>
<v t="BIGZHU.20070802223007.11"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.12"><vh>addLine</vh></v>
<v t="BIGZHU.20070802223007.13"><vh>getNLines</vh></v>
<v t="BIGZHU.20070802223007.14"><vh>intelliLen</vh></v>
<v t="BIGZHU.20070802223007.15"><vh>wrap</vh></v>
</v>
<v t="BIGZHU.20070802223007.16"><vh>class ColorCoder</vh>
<v t="BIGZHU.20070802223007.17"><vh>&lt;&lt; class ColorCoder declarations &gt;&gt;</vh></v>
<v t="BIGZHU.20070802223007.18"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.19"><vh>stripCodes</vh></v>
<v t="BIGZHU.20070802223007.20"><vh>setCodeSet</vh></v>
<v t="BIGZHU.20070802223007.21"><vh>isValidSet</vh></v>
<v t="BIGZHU.20070802223007.22"><vh>colorSupported</vh></v>
<v t="BIGZHU.20070802223007.23"><vh>usingColor</vh></v>
<v t="BIGZHU.20070802223007.24"><vh>code</vh></v>
<v t="BIGZHU.20070802223007.25"><vh>printCode</vh></v>
<v t="BIGZHU.20070802223007.26"><vh>getCodeSet</vh></v>
</v>
<v t="BIGZHU.20070802223007.27"><vh>class ListViewer</vh>
<v t="BIGZHU.20070802223007.28"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.29"><vh>show</vh></v>
</v>
<v t="BIGZHU.20070802223007.30"><vh>class Encryptor</vh>
<v t="BIGZHU.20070802223007.31"><vh>&lt;&lt; class Encryptor declarations &gt;&gt;</vh></v>
<v t="BIGZHU.20070802223007.32"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.33"><vh>setType</vh></v>
<v t="BIGZHU.20070802223007.34"><vh>setKey</vh></v>
<v t="BIGZHU.20070802223007.35"><vh>getKey</vh></v>
<v t="BIGZHU.20070802223007.36"><vh>enterKey</vh></v>
<v t="BIGZHU.20070802223007.37"><vh>complexKey</vh></v>
<v t="BIGZHU.20070802223007.38"><vh>getSecurityClass</vh></v>
<v t="BIGZHU.20070802223007.39"><vh>obscure</vh></v>
<v t="BIGZHU.20070802223007.40"><vh>unobscure</vh></v>
<v t="BIGZHU.20070802223007.41"><vh>encryptAes</vh></v>
<v t="BIGZHU.20070802223007.42"><vh>decryptAes</vh></v>
<v t="BIGZHU.20070802223007.43"><vh>enterKeyAndEncrypt</vh></v>
<v t="BIGZHU.20070802223007.44"><vh>encrypt</vh></v>
<v t="BIGZHU.20070802223007.45"><vh>enterKeyAndDecrypt</vh></v>
<v t="BIGZHU.20070802223007.46"><vh>decrypt</vh></v>
</v>
<v t="BIGZHU.20070802223007.47"><vh>class InputParser</vh>
<v t="BIGZHU.20070802223007.48"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.49"><vh>read</vh></v>
</v>
<v t="BIGZHU.20070802223007.50"><vh>class EditorLauncher</vh>
<v t="BIGZHU.20070802223007.51"><vh>&lt;&lt; class EditorLauncher declarations &gt;&gt;</vh></v>
<v t="BIGZHU.20070802223007.52"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.53"><vh>edit</vh></v>
<v t="BIGZHU.20070802223007.54"><vh>scrubFile</vh></v>
<v t="BIGZHU.20070802223007.55"><vh>readFile</vh></v>
<v t="BIGZHU.20070802223007.56"><vh>safeString</vh></v>
<v t="BIGZHU.20070802223007.57"><vh>makeFile</vh></v>
<v t="BIGZHU.20070802223007.58"><vh>run</vh></v>
<v t="BIGZHU.20070802223007.59"><vh>runProgram</vh></v>
</v>
<v t="BIGZHU.20070802223007.60"><vh>class TodoList</vh>
<v t="BIGZHU.20070802223007.61"><vh>&lt;&lt; class TodoList declarations &gt;&gt;</vh></v>
<v t="BIGZHU.20070802223007.62"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.63"><vh>setPAbbreviation</vh></v>
<v t="BIGZHU.20070802223007.64"><vh>showPAbbreviations</vh></v>
<v t="BIGZHU.20070802223007.65"><vh>setAbbreviation</vh></v>
<v t="BIGZHU.20070802223007.66"><vh>showAbbreviations</vh></v>
<v t="BIGZHU.20070802223007.67"><vh>setShortcut</vh></v>
<v t="BIGZHU.20070802223007.68"><vh>showShortcuts</vh></v>
<v t="BIGZHU.20070802223007.69"><vh>setShortcuts</vh></v>
<v t="BIGZHU.20070802223007.70"><vh>getShortcutIndex</vh></v>
<v t="BIGZHU.20070802223007.71"><vh>getShortcut</vh></v>
<v t="BIGZHU.20070802223007.72"><vh>safeSystemCall</vh></v>
<v t="BIGZHU.20070802223007.73"><vh>processCfgLine</vh></v>
<v t="BIGZHU.20070802223007.74"><vh>makeFilename</vh></v>
<v t="BIGZHU.20070802223007.75"><vh>findDataSource</vh></v>
<v t="BIGZHU.20070802223007.76"><vh>setSysCalls</vh></v>
<v t="BIGZHU.20070802223007.77"><vh>setAutoSave</vh></v>
<v t="BIGZHU.20070802223007.78"><vh>showError</vh></v>
<v t="BIGZHU.20070802223007.79"><vh>pause</vh></v>
<v t="BIGZHU.20070802223007.80"><vh>setReview</vh></v>
<v t="BIGZHU.20070802223007.81"><vh>sortByPriority</vh></v>
<v t="BIGZHU.20070802223007.82"><vh>run</vh></v>
<v t="BIGZHU.20070802223007.83"><vh>timeout</vh></v>
<v t="BIGZHU.20070802223007.84"><vh>runTimer</vh></v>
<v t="BIGZHU.20070802223007.85"><vh>addTaskExternal</vh></v>
<v t="BIGZHU.20070802223007.86"><vh>addTask</vh></v>
<v t="BIGZHU.20070802223007.87"><vh>checkCurrentTask</vh></v>
<v t="BIGZHU.20070802223007.88"><vh>writeArchive</vh></v>
<v t="BIGZHU.20070802223007.89"><vh>exportTasks</vh></v>
<v t="BIGZHU.20070802223007.90"><vh>importTasks</vh></v>
<v t="BIGZHU.20070802223007.91"><vh>createFile</vh></v>
<v t="BIGZHU.20070802223007.92"><vh>save</vh></v>
<v t="BIGZHU.20070802223007.93"><vh>forceSave</vh></v>
<v t="BIGZHU.20070802223007.94"><vh>moveTo</vh></v>
<v t="BIGZHU.20070802223007.95"><vh>moveToVisible</vh></v>
<v t="BIGZHU.20070802223007.96"><vh>decrypt</vh></v>
<v t="BIGZHU.20070802223007.97"><vh>moveTask</vh></v>
<v t="BIGZHU.20070802223007.98"><vh>clear</vh></v>
<v t="BIGZHU.20070802223007.99"><vh>getRequiredTask</vh></v>
<v t="BIGZHU.20070802223007.100"><vh>archiveTask</vh></v>
<v t="BIGZHU.20070802223007.101"><vh>removeTask</vh></v>
<v t="BIGZHU.20070802223007.102"><vh>substituteText</vh></v>
<v t="BIGZHU.20070802223007.103"><vh>modifyTask</vh></v>
<v t="BIGZHU.20070802223007.104"><vh>incTask</vh></v>
<v t="BIGZHU.20070802223007.105"><vh>incTaskLoop</vh></v>
<v t="BIGZHU.20070802223007.106"><vh>decTask</vh></v>
<v t="BIGZHU.20070802223007.107"><vh>decTaskLoop</vh></v>
<v t="BIGZHU.20070802223007.108"><vh>printItemTruncated</vh></v>
<v t="BIGZHU.20070802223007.109"><vh>printItem</vh></v>
<v t="BIGZHU.20070802223007.110"><vh>printItemVerbose</vh></v>
<v t="BIGZHU.20070802223007.111"><vh>clearFilterArray</vh></v>
<v t="BIGZHU.20070802223007.112"><vh>setFilterArray</vh></v>
<v t="BIGZHU.20070802223007.113"><vh>isViewable</vh></v>
<v t="BIGZHU.20070802223007.114"><vh>listByAction</vh></v>
<v t="BIGZHU.20070802223007.115"><vh>listByProject</vh></v>
<v t="BIGZHU.20070802223007.116"><vh>listByDate</vh></v>
<v t="BIGZHU.20070802223007.117"><vh>showFilter</vh></v>
<v t="BIGZHU.20070802223007.118"><vh>showLocalFilter</vh></v>
<v t="BIGZHU.20070802223007.119"><vh>printList</vh></v>
<v t="BIGZHU.20070802223007.120"><vh>printShortList</vh></v>
<v t="BIGZHU.20070802223007.121"><vh>doPrintList</vh></v>
<v t="BIGZHU.20070802223007.122"><vh>printHelp</vh></v>
<v t="BIGZHU.20070802223007.123"><vh>splitFile</vh></v>
<v t="BIGZHU.20070802223007.124"><vh>createItem</vh></v>
<v t="BIGZHU.20070802223007.125"><vh>outputHtml</vh></v>
<v t="BIGZHU.20070802223007.126"><vh>output</vh></v>
<v t="BIGZHU.20070802223007.127"><vh>startHtml</vh></v>
<v t="BIGZHU.20070802223007.128"><vh>endHtml</vh></v>
</v>
<v t="BIGZHU.20070802223007.129"><vh>class Abbreviations</vh>
<v t="BIGZHU.20070802223007.130"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.131"><vh>default</vh></v>
<v t="BIGZHU.20070802223007.132"><vh>setAbbreviations</vh></v>
<v t="BIGZHU.20070802223007.133"><vh>addAbbreviation</vh></v>
<v t="BIGZHU.20070802223007.134"><vh>removeAbbreviation</vh></v>
<v t="BIGZHU.20070802223007.135"><vh>expandAction</vh></v>
<v t="BIGZHU.20070802223007.136"><vh>expandProject</vh></v>
<v t="BIGZHU.20070802223007.137"><vh>toString</vh></v>
<v t="BIGZHU.20070802223007.138"><vh>toStringVerbose</vh></v>
</v>
<v t="BIGZHU.20070802223007.139"><vh>class SearchIndex</vh>
<v t="BIGZHU.20070802223007.140"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.141"><vh>add</vh></v>
<v t="BIGZHU.20070802223007.142"><vh>addCollection</vh></v>
<v t="BIGZHU.20070802223007.143"><vh>sort</vh></v>
<v t="BIGZHU.20070802223007.144"><vh>getFirstItem</vh></v>
<v t="BIGZHU.20070802223007.145"><vh>getNextItem</vh></v>
</v>
<v t="BIGZHU.20070802223007.146"><vh>class TodoItem</vh>
<v t="BIGZHU.20070802223007.147"><vh>&lt;&lt; class TodoItem declarations &gt;&gt;</vh></v>
<v t="BIGZHU.20070802223007.148"><vh>__init__</vh></v>
<v t="BIGZHU.20070802223007.149"><vh>makeSafeDate</vh></v>
<v t="BIGZHU.20070802223007.150"><vh>parseDate</vh></v>
<v t="BIGZHU.20070802223007.151"><vh>parse</vh></v>
<v t="BIGZHU.20070802223007.152"><vh>addError</vh></v>
<v t="BIGZHU.20070802223007.153"><vh>hasError</vh></v>
<v t="BIGZHU.20070802223007.154"><vh>getError</vh></v>
<v t="BIGZHU.20070802223007.155"><vh>hasWord</vh></v>
<v t="BIGZHU.20070802223007.156"><vh>hasAction</vh></v>
<v t="BIGZHU.20070802223007.157"><vh>copy</vh></v>
<v t="BIGZHU.20070802223007.158"><vh>hasHiddenTask</vh></v>
<v t="BIGZHU.20070802223007.159"><vh>hasTask</vh></v>
<v t="BIGZHU.20070802223007.160"><vh>hasProject</vh></v>
<v t="BIGZHU.20070802223007.161"><vh>hasDate</vh></v>
<v t="BIGZHU.20070802223007.162"><vh>hasPriorityOrAbove</vh></v>
<v t="BIGZHU.20070802223007.163"><vh>hasPriority</vh></v>
<v t="BIGZHU.20070802223007.164"><vh>getHiddenTask</vh></v>
<v t="BIGZHU.20070802223007.165"><vh>getTask</vh></v>
<v t="BIGZHU.20070802223007.166"><vh>getActions</vh></v>
<v t="BIGZHU.20070802223007.167"><vh>getProjects</vh></v>
<v t="BIGZHU.20070802223007.168"><vh>getDate</vh></v>
<v t="BIGZHU.20070802223007.169"><vh>getPriority</vh></v>
<v t="BIGZHU.20070802223007.170"><vh>getEffectivePriority</vh></v>
<v t="BIGZHU.20070802223007.171"><vh>toString</vh></v>
<v t="BIGZHU.20070802223007.172"><vh>toStringEditable</vh></v>
<v t="BIGZHU.20070802223007.173"><vh>toStringSimple</vh></v>
<v t="BIGZHU.20070802223007.174"><vh>toStringVerbose</vh></v>
</v>
</v>
<v t="BIGZHU.20070806144525" a="TV" tnodeList="BIGZHU.20070806144525"><vh>@file d:/BIGZHU/Python/python_project/toexe.py</vh></v>
</vnodes>
<tnodes>
<t tx="BIGZHU.20070731151011"></t>
<t tx="BIGZHU.20070802223007">@ignore
@language python
&lt;&lt; ikog declarations &gt;&gt;
@others
@
一个python 写的GTD 工具
@c
### Entry point
for line in notice:
    print line

pythonVer = platform.python_version()
ver = pythonVer.split(".")
if int(ver[0]) &lt; gReqPythonMajor or (int(ver[0]) == gReqPythonMajor and int(ver[1]) &lt; gReqPythonMinor):
    print "\nSorry but this program requires Python ", \
    str(gReqPythonMajor) + "." + str(gReqPythonMinor), \
    "\nYour current version is ", \
    str(ver[0]) + "." + str(ver[1]), \
    "\nTo run the program you will need to install the current version of Python."
else:
    import webbrowser
    # signal.signal(signal.SIGINT, signalHandler)
    gColor = ColorCoder(cfgColor)
    globalAbbr = Abbreviations()
    globalPAbbr = Abbreviations(project=True)
    commandList = []
    if len(sys.argv) &gt; 2:
        command = ""
        reopen = sys.argv[1]
        if reopen == ".":
            reopen = sys.argv[0] + ".dat"
        for word in sys.argv[2:]:
            if word == "/":
                commandList.append(command)
                command = ""
            else:
                command = command + word + " "
        commandList.append(command)
    elif len(sys.argv) &gt; 1:
        reopen = sys.argv[1]
    else:
        reopen = sys.argv[0] + ".dat"
    while reopen != "":
        print commandList
        todoList = TodoList(sys.argv[0], reopen)
        reopen = todoList.run(commandList)
        commandList = []
print "Goodbye"

</t>
<t tx="BIGZHU.20070802223007.1">#!/usr/bin/env python
# -*- coding: utf-8 -*-
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Run the script for details of the licence
# or refer to the notice section later in the file.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!&lt;^DATA
# +买一双鞋子  @Anywhere :pNone :created2007-08-02
# +下去吃夜宵  @Anywhere :pNone :created2007-08-02
#!&lt;^CONFIG
cfgColor = 0
cfgAutoSave = True
cfgReviewMode = True
cfgSysCalls = False
cfgEditorNt = "edit"
cfgEditorPosix = "nano,pico,vim,emacs"
cfgShortcuts = ['', '', '', '', '', '', '', '', '', '']
cfgAbbreviations = {'@C': '@Computer', '@A': '@Anywhere', '@Pw': '@Password', '@D': '@Desk', '@E': '@Errands', '@H': '@Home', '@I': '@Internet', '@N': '@Next', '@O': '@Other', '@L': '@Lunch', '@M': '@Meeting', '@S': '@Someday/Maybe', '@P': '@Phone', '@W4': '@Waiting_For', '@W': '@Work'}
cfgPAbbreviations = {}
#!&lt;^CODE
import sys
import os
import re
from datetime import date
from datetime import timedelta
import platform
import urllib
import getpass
from md5 import md5
import struct
import tempfile
from threading import Timer
import stat

supportAes = True
try:
    import pyRijndael
except:
    supportAes = False

try:
    import readline
except:
    pass

notice = [
"ikog.py v 1.87 2007-05-06",
"Copyright (C) 2006-2007 S. J. Butler",
"Visit http://www.henspace.co.uk for more information.",
"This program is free software; you can redistribute it and/or modify",
"it under the terms of the GNU General Public Licence as published by",
"the Free Software Foundation; either version 2 of the License, or",
"(at your option) any later version.",
"",
"This program is distributed in the hope that it will be useful,",
"but WITHOUT ANY WARRANTY; without even the implied warranty of",
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
"GNU General Public License for more details.  The license is available",
"from http://www.gnu.org/licenses/gpl.txt"
]

banner = [
"                      _   _ ",
"                     (_) | | __   ___     __ _",
"                     | | | |/ /  / _ \   / _` |",
"                     | | |   &lt;  | (_) | | (_| |",
"                     |_| |_|\_\  \___/   \__, |",
"   _   _        _                        |___/",
"  (_) | |_     | | __   ___    ___   _ __     ___       ___    _ __",
"  | | | __|    | |/ /  / _ \  / _ \ | '_ \   / __|     / _ \  | '_ \ ",
"  | | | |_     |   &lt;  |  __/ |  __/ | |_) |  \__ \    | (_) | | | | |",
"  |_|  \__|    |_|\_\  \___|  \___| | .__/   |___/     \___/  |_| |_|",
"                                    |_|    _",
"          __ _   _ __    ___   __      __ (_)  _ __     __ _ ",
"         / _` | | '__|  / _ \  \ \ /\ / / | | | '_ \   / _` |",
"        | (_| | | |    | (_) |  \ V  V /  | | | | | | | (_| |  _",
"         \__, | |_|     \___/    \_/\_/   |_| |_| |_|  \__, | (_)",
"         |___/                                         |___/",
]



magicTag = "#!&lt;^"
gMaxLen = 80
try:
    ruler   = "~".ljust(gMaxLen - 1, "~")
    divider = "_".ljust(gMaxLen - 1, "_")
except Exception:
    print "Error found.  Probably wrong version of Python"

gReqPythonMajor = 2
gReqPythonMinor = 4


</t>
<t tx="BIGZHU.20070802223007.2">def safeRawInput(prompt):
    try:
        entry = raw_input(prompt)
    except:
        print "\n"
        entry = ""
    return entry
</t>
<t tx="BIGZHU.20070802223007.3">### global compare function
def compareTodo(a, b):
    return cmp(a.getEffectivePriority(), b.getEffectivePriority())
</t>
<t tx="BIGZHU.20070802223007.4">def printError(msg):
    print gColor.code("error") + "ERROR: " + msg + gColor.code("normal")
</t>
<t tx="BIGZHU.20070802223007.5">def clearScreen(useSys = False):
    if useSys:
        if os.name == "posix":
            os.system("clear")
        elif os.name in ("dos", "ce", "nt"):
            os.system("cls")
    print "\n"*25
    for l in banner:
        print l
</t>
<t tx="BIGZHU.20070802223007.6">
### XTEA algorithm public domain
class Xtea:
	@others
</t>
<t tx="BIGZHU.20070802223007.7">def __init__(self):
    pass
</t>
<t tx="BIGZHU.20070802223007.8">def crypt(self, key,data,iv='\00\00\00\00\00\00\00\00',n=32):
    def keygen(key,iv,n):
        while True:
            iv = self.xtea_encrypt(key,iv,n)
            for k in iv:
                yield ord(k)
    xor = [ chr(x^y) for (x,y) in zip(map(ord,data),keygen(key,iv,n)) ]
    return "".join(xor)
</t>
<t tx="BIGZHU.20070802223007.9">def xtea_encrypt(self, key,block,n=32):
    v0,v1 = struct.unpack("!2L",block)
    k = struct.unpack("!4L",key)
    sum,delta,mask = 0L,0x9e3779b9L,0xffffffffL
    for round in range(n):
        v0 = (v0 + (((v1&lt;&lt;4 ^ v1&gt;&gt;5) + v1) ^ (sum + k[sum &amp; 3]))) &amp; mask
        sum = (sum + delta) &amp; mask
        v1 = (v1 + (((v0&lt;&lt;4 ^ v0&gt;&gt;5) + v0) ^ (sum + k[sum&gt;&gt;11 &amp; 3]))) &amp; mask
    return struct.pack("!2L",v0,v1)
</t>
<t tx="BIGZHU.20070802223007.10">
class WordWrapper:
	@others
</t>
<t tx="BIGZHU.20070802223007.11">def __init__(self, width):
    self.width = width
    self.nLines = 0
    self.pos = 0
</t>
<t tx="BIGZHU.20070802223007.12">def addLine(self, pos):
    self.pos = pos
    self.nLines = self.nLines + 1
</t>
<t tx="BIGZHU.20070802223007.13">def getNLines(self):
    return self.nLines
</t>
<t tx="BIGZHU.20070802223007.14">def intelliLen(self, text):
   return len(gColor.stripCodes(text))
</t>
<t tx="BIGZHU.20070802223007.15">def wrap(self, text):
    self.nLines = 0
    formatted = text.replace("&lt;br&gt;", "\n").replace("&lt;BR&gt;", "\n")
    lines = formatted.splitlines()
    out = ""
    self.pos = 0
    for thisline in lines:
        newline = True
        words = thisline.split()
        if self.pos != 0:
            out = out + "\n"
            self.addLine(0)
        for w in words:
            wlen = self.intelliLen(w) + 1
            if (self.pos + wlen) == self.width:
                out = out + " " + w
                self.addLine(0)
            elif (self.pos + wlen) &lt; self.width:
                if newline:
                    out =  out + w
                    self.pos = wlen
                else:
                    out = out + " " + w
                    self.pos = self.pos + wlen + 1
            else:
                out = out + "\n" + w
                self.addLine(wlen)
            newline = False
    return out
</t>
<t tx="BIGZHU.20070802223007.16">
### Color code class for handling color text output
class ColorCoder:
	&lt;&lt; class ColorCoder declarations &gt;&gt;
	@others
</t>
<t tx="BIGZHU.20070802223007.17">NONE = -1
ANSI = 0
codes = [{"normal":"\x1b[0;37;40m",
        "title":"\x1b[1;32;40m",
        "heading":"\x1b[1;35;40m",
        "bold":"\x1b[1;35;40m",
        "important":"\x1b[1;31;40m",
        "error":"\x1b[1;31;40m",
        "reverse":"\x1b[0;7m",
        "row0":"\x1b[0;35;40m",
        "row1":"\x1b[0;36;40m"},
        {"normal":"\x1b[0;37m",
        "title":"\x1b[1;32m",
        "heading":"\x1b[1;35m",
        "bold":"\x1b[1;35m",
        "important":"\x1b[1;31m",
        "error":"\x1b[1;31m",
        "reverse":"\x1b[0;7m",
        "row0":"\x1b[0;35m",
        "row1":"\x1b[0;36m"}]

</t>
<t tx="BIGZHU.20070802223007.18">def __init__(self, set):
    self.codeSet = self.NONE
    self.setCodeSet(set)
</t>
<t tx="BIGZHU.20070802223007.19">def stripCodes(self, text):
    # strip out the ansi codes
    ex = re.compile("\x1b\[[0-9;]*m")
    return ex.sub("", text)
</t>
<t tx="BIGZHU.20070802223007.20">def setCodeSet(self, set):
    old = self.codeSet
    if set &lt; 0:
        self.codeSet = self.NONE
    elif set &lt; len(self.codes):
        self.codeSet = set
    return (old != self.codeSet)
</t>
<t tx="BIGZHU.20070802223007.21">def isValidSet(self, myset):
    if myset &lt; len(self.codes):
        return True
    else:
        return False
</t>
<t tx="BIGZHU.20070802223007.22">def colorSupported(self):
    return (os.name == "posix" or os.name == "mac")
</t>
<t tx="BIGZHU.20070802223007.23">def usingColor(self):
    return (self.codeSet &lt;&gt; self.NONE and self.colorSupported())
</t>
<t tx="BIGZHU.20070802223007.24">def code(self, type):
    if self.codeSet == self.NONE or not self.colorSupported():
        return ""
    else:
        return self.codes[self.codeSet][type]
</t>
<t tx="BIGZHU.20070802223007.25">def printCode(self, type):
    if self.codeSet != self.NONE:
        print self.code(type),
</t>
<t tx="BIGZHU.20070802223007.26">def getCodeSet(self):
    return self.codeSet
</t>
<t tx="BIGZHU.20070802223007.27">
### Viewer class for paging through multiple lines
class ListViewer:
	@others
</t>
<t tx="BIGZHU.20070802223007.28">def __init__(self, maxlines):
    self.maxlines = maxlines
</t>
<t tx="BIGZHU.20070802223007.29">def show(self, list, pause):
    count = 0
    for line in list:
        if count &gt;= self.maxlines or line == pause:
            io = safeRawInput("--- Press enter for more. Enter s to skip ---").strip()
            print ""
            if len(io) &gt; 0 and io.upper()[0] == "S":
                break
            count = 0
        if line != pause:
            print line
        count = count + 1
</t>
<t tx="BIGZHU.20070802223007.30">
### Handler for encryption
class Encryptor:
	&lt;&lt; class Encryptor declarations &gt;&gt;
	@others
</t>
<t tx="BIGZHU.20070802223007.31">TYPE_OBSCURED = "xtea_"
TYPE_AES = "aes_"
SALT_64 = "1hJ8*gpQ"

</t>
<t tx="BIGZHU.20070802223007.32">def __init__(self):
    self.key = ""
    self.encryptionType = self.TYPE_OBSCURED
</t>
<t tx="BIGZHU.20070802223007.33">def setType(self, codeType):
    if codeType == self.TYPE_AES and supportAes == False:
        self.encryptionType = self.TYPE_OBSCURED
    else:
        self.encryptionType = codeType
    return self.encryptionType
</t>
<t tx="BIGZHU.20070802223007.34">def setKey(self, key):
    self.key = key
</t>
<t tx="BIGZHU.20070802223007.35">def getKey(self):
    return self.key
</t>
<t tx="BIGZHU.20070802223007.36">def enterKey(self, prompt1, prompt2):
    done = False
    while not done:
        input1 = getpass.getpass(prompt1 + " &gt;&gt;&gt;")
        if prompt2 != "":
            input2 = getpass.getpass(prompt2 + " &gt;&gt;&gt;")
            if input1 != input2:
                print "You must enter the same password.  Start again"
            else:
                done = True
        else:
            done = True
    self.key = input1
    return input1
</t>
<t tx="BIGZHU.20070802223007.37">def complexKey(self):
    return md5(self.key).digest()
</t>
<t tx="BIGZHU.20070802223007.38">def getSecurityClass(self, encrypted):
    if encrypted.startswith(self.TYPE_OBSCURED):
        return "private xtea"
    if encrypted.startswith(self.TYPE_AES):
        return "secret aes"
    return "unknown"
</t>
<t tx="BIGZHU.20070802223007.39">def obscure(self, plainText):
    key = self.complexKey()
    obscured = Xtea().crypt(key, plainText, self.SALT_64)
    return self.TYPE_OBSCURED + obscured.encode('hex_codec')
</t>
<t tx="BIGZHU.20070802223007.40">def unobscure(self, obscured):
    plain = ""
    data = obscured[len(self.TYPE_OBSCURED):]
    data = data.decode('hex_codec')
    key = self.complexKey()
    plain = Xtea().crypt(key, data, self.SALT_64)
    return plain
</t>
<t tx="BIGZHU.20070802223007.41">def encryptAes(self, plainText):
    if len(self.key) &lt; 16:
        key = self.complexKey()
    else:
        key = self.key
    obscured = pyRijndael.EncryptData(key, plainText)
    return self.TYPE_AES + obscured.encode('hex_codec')
</t>
<t tx="BIGZHU.20070802223007.42">def decryptAes(self, encrypted):
    plain = ""
    data = encrypted[len(self.TYPE_AES):]
    data = data.decode('hex_codec')
    if len(self.key) &lt; 16:
        key = self.complexKey()
    else:
        key = self.key
    plain = pyRijndael.DecryptData(key, data)
    return plain
</t>
<t tx="BIGZHU.20070802223007.43">def enterKeyAndEncrypt(self, plainText):
    self.enterKey("Enter the master password.", "Re-enter the master password")
    return self.encrypt(plainText)
</t>
<t tx="BIGZHU.20070802223007.44">def encrypt(self, plainText):
    if self.encryptionType == self.TYPE_AES:
        return self.encryptAes(plainText)
    else:
        return  self.obscure(plainText)
</t>
<t tx="BIGZHU.20070802223007.45">def enterKeyAndDecrypt(self, encryptedText):
    self.enterKey("Enter your master password", "")
    return self.decrypt(encryptedText)
</t>
<t tx="BIGZHU.20070802223007.46">def decrypt(self, encryptedText):
    if encryptedText.startswith(self.TYPE_AES):
        if not supportAes:
            return "You do not have the pyRinjdael module so the text cannot be decrypted."
        else:
            return self.decryptAes(encryptedText)
    else:
        return self.unobscure(encryptedText)
</t>
<t tx="BIGZHU.20070802223007.47">
### Handler for user input
class InputParser:
	@others
</t>
<t tx="BIGZHU.20070802223007.48">def __init__(self, prompt):
    self.prompt = prompt
</t>
<t tx="BIGZHU.20070802223007.49">def read(self, entry = ""):
    if entry == "":
        entry = safeRawInput(self.prompt)
    entry = entry.strip()
    if entry == "":
        command = ""
        line = ""
    else:
        if entry.find(magicTag) == 0:
            printError("You cannot begin lines with the sequence " + magicTag)
            command = ""
            line = ""
        elif entry.find(TodoItem.ENCRYPTION_MARKER) &gt;= 0:
            printError ("You cannot use the special sequence " + TodoItem.ENCRYPTION_MARKER)
            command = ""
            line = ""
        else:
            n = entry.find(" ")
            if n &gt;= 0:
                command = entry[:n]
                line = entry[n + 1:]
            else:
                command = entry
                line = ""

    return (command, line)
</t>
<t tx="BIGZHU.20070802223007.50">
class EditorLauncher:
	&lt;&lt; class EditorLauncher declarations &gt;&gt;
	@others
</t>
<t tx="BIGZHU.20070802223007.51">WARNING_TEXT = "# Do not enter secret or private information!"
</t>
<t tx="BIGZHU.20070802223007.52">def __init__(self):
    pass
</t>
<t tx="BIGZHU.20070802223007.53">def edit(self, text):
    ed = ""
    terminator = "\n"
    if os.name == "posix":
        ed = cfgEditorPosix
    elif os.name == "nt":
        ed = cfgEditorNt
        terminator = "\r\n"
    if ed == "":
        printError("Sorry, but external editing not supported on " + os.name.upper())
        success = False
    else:
        fname = self.makeFile(text, terminator)
        if fname == "":
            printError("Unable to create temporary file.")
        else:
            success = self.run(ed, fname)
            if success:
                (success, text) = self.readFile(fname)
            if text == self.orgText:
                print("No changes made.");
                success = False
            self.scrubFile(fname)
    if success:
        return text
    else:
        return ""
</t>
<t tx="BIGZHU.20070802223007.54">def scrubFile(self, fname):
    try:
        os.remove(fname)
    except Exception, e:
        printError("Failed to remove file " + fname + ". If you entered any private data you should delete this file yourself.")
</t>
<t tx="BIGZHU.20070802223007.55">def readFile(self, fname):
    success = False
    try:
        fh = open(fname, "rt")
        line = fh.readline()
        text = ""
        first = True
        while line != "":
            thisLine = self.safeString(line)
            if thisLine != self.WARNING_TEXT:
                if not first:
                    text = text + "&lt;br&gt;"
                text = text + thisLine
                first = False
            line = fh.readline()
        fh.close()
        success = True
    except Exception, e:
        printError("Error reading the edited text. " + str(e))
    return (success, text)
</t>
<t tx="BIGZHU.20070802223007.56">def safeString(self, text):
    return text.replace("\r","").replace("\n","")
</t>
<t tx="BIGZHU.20070802223007.57">def makeFile(self, text, terminator):
    fname = ""
    (fh, fname) = tempfile.mkstemp(".tmpikog","ikog")
    fout = os.fdopen(fh,"wt")
    text = text.replace("&lt;BR&gt;", "&lt;br&gt;")
    self.orgText = text
    lines = text.split("&lt;br&gt;")
    fout.write(self.WARNING_TEXT + terminator)
    for thisline in lines:
        fout.write(self.safeString(thisline) + terminator)
    fout.close()
    return fname
</t>
<t tx="BIGZHU.20070802223007.58">def run(self, program, file):
    progs = program.split(",")
    for prog in progs:
        success = self.runProgram(prog.strip(), file)
        if success:
            break;
    return success
</t>
<t tx="BIGZHU.20070802223007.59">def runProgram(self, program, file):
    success = False
    if os.name == "posix":
        try:
            progarg = program
            os.spawnlp(os.P_WAIT, program, progarg, file)
            success = True
        except os.error:
            pass
        except Exception, e:
            printError(str(e))
    elif os.name == "nt":
        if file.find(" ") &gt;= 0:
            file = "\"" + file + "\""
        for path in os.environ["PATH"].split(os.pathsep):
            try:
                prog = os.path.join(path, program)
                if prog.find(" ") &gt;= 0:
                    progarg = "\"" + prog + "\""
                else:
                    progarg = prog
                os.spawnl(os.P_WAIT, prog, progarg, file)
                success = True
                if success:
                    break
            except os.error:
                pass
            except Exception, e:
                printError(str(e))
    return success
</t>
<t tx="BIGZHU.20070802223007.60">

### The main todo list
class TodoList:
	&lt;&lt; class TodoList declarations &gt;&gt;
	@others
</t>
<t tx="BIGZHU.20070802223007.61">quickCard = ["Quick reference card:",
"?                     ADD/A/+ text          FILTER/FI [filter]",
"HELP/H                IMMEDIATE/I/++ text   TOP/T [N]",
"COLOR/COLOUR/C [N]    KILL/K/X/- N          NEXT/N",
"MONOCHROME/MONO       CLEAR                 PREV/P",
"EXPORT                REP/R N [text]        GO/G N",
"IMPORT file           MOD/M N [text]        LIST/L [filter]",
"REVIEW/REV ON/OFF     EXTEND/E N [text]     LIST&gt;/L&gt; [filter]",
"V0                    EDIT/ED [N]           @",
"V1                    SUB/SU N /s1/s2/      :D",
"WEB                   FIRST/F N             :P&gt;",
"SAVE/S                DOWN/D N              @&gt;",
"AUTOSAVE/AS ON|OFF    UP/U N                :D&gt;",
"VER/VERSION           NOTE/NOTES text       :P&gt;",
"CLEARSCREEN/CLS       O/OPEN file           SHOW N",
"SYS ON|OFF            NEW file              SETEDxx editor",
"!CMD command          2                     ABBREV/AB @x @full",
"ABBREV/AB ?           PAB ?                 PAB :px :pfull",
"SHORTCUT/SC N cmd     SHORTCUT/SC ?         =N",
"ARCHIVE/DONE N [text]",
]

help = [ "",
"Introduction",
"------------",
"The program is designed to help manage tasks using techniques",
"such as Getting Things Done by David Allen. Check out",
"http://www.henspace.co.uk for more information and detailed help.",
"To use the program, simply enter the task at the prompt.",
"All of the commands are displayed in the next section.",
"!PAUSE!",
"COMMANDS",
"--------",
"Commands that have more than one method of entry are shown separated by /",
"e.g HELP/H means that you can enter either HELP or an H.",
"All commands can be entered in upper or lower case.",
"Items shown in square brackets are optional.",
"Items shown separated by the | symbol are alternatives.  e.g ON|OFF means",
"you should type either ON or OFF.",
"Note that some commands refer to adding tasks to the top or bottom of the",
"list.  However the task's position in the list is also determined by its.",
"priority.  So, for example, adding a task to the top will still not allow",
"it to precede tasks that have been assigned a higher priority number. ",
"!PAUSE!",
"GENERAL COMMANDS",
"----------------",
"?                  : displays a quick reference card",
"HELP/H             : displays this help.",
"VERSION/VER        : display the version.",
"WEB                : Go to the website for more information",
"CLEARSCREEN/CLS    : Clear the screen",
"COLOR/COLOUR/C [N] : Use colour display (not Windows) N=1 for no background",
"MONOCHROME/MONO    : Use monochrome display",
"EXPORT             : Export the tasks only to filename.tasks.txt",
"IMPORT file        : Import tasks from the file",
"REVIEW/REV ON|OFF  : If on, hitting enter moves to the next task",
"                   : If off, enter re-displays the current task",
"V0                 : Same as REVIEW OFF",
"V1                 : Same as REVIEW ON",
"SAVE/S             : Save the tasks",
"O/OPEN file        : Open a new data file.",
"NEW file           : Create a new data file.",
"AUTOSAVE/AS ON|OFF : Switch autosave on or off",
"SYS ON|OFF         : Allow the program to use system calls.",
"!CMD  command      : Run a system command.",
"2                  : Start a two minute timer (for GTD)",
"QUIT/Q             : quit the program",
"!PAUSE!",
"TASK ENTRY AND EDITING COMMANDS",
"-------------------------------",
"For the editing commands that require a task number, you can",
"replace N by '^' or 'this' to refer to the current task.",
"ADD/A/+ the task   : add a task to the bottom of the list.",
"                   : Entering any line that does not begin with",
"                   : a valid command and which is greater than 10",
"                   : characters long is also assumed to be an addition.",
"EDIT/ED [N]        : Create task, or edit task N, using external editor.",
"SUB/SU N /s1/s2/   : Replace text s1 with s2 in task N. Use \/ if you",
"                   : need to include the / character.",
"NOTE/NOTES text    : shorthand for ADD #0 @Notes text",
"IMMEDIATE/I/++     : add a task to the top of the list to do today.",
"REP/R N [text]     : replace task N",
"MOD/M N [text]     : modify task N.",
"EXTEND/E N [text]  : add more text to task N",
"FIRST/F N          : move task N to the top.",
"DOWN/D/ N          : move task N down the queue",
"UP/U/ N            : move task N up the queue",
"!PAUSE!",
"TASK REMOVAL COMMANDS",
"---------------------",
"KILL/K/X/- N       : kill (delete) task N. You must define N",
"DONE N [text]      : Remove task N and move to an archive file",
"ARCHIVE N [text]   : Same as DONE",
"CLEAR              : Remove all tasks",
"!PAUSE!",
"DISPLAY COMMANDS",
"----------------",
"SHOW N             : display encrypted text for task N",
"FILTER/FI [filter] : set a filter.  Applies to all displays",
"                   : See list for details of the filter",
"                   : Setting the filter to nothing clears it.",
"TOP/T [N]          : Go to top, list N tasks, and display the top task",
"NEXT/N             : display the next task. Same as just hitting enter",
"PREV/P             : display previous task",
"GO/G N             : display task N",
"LIST/L [filter]    : list tasks. Filter = context, project, priority, date",
"                   : or word. Contexts begin with @ and projects with :p",
"                   : Dates begin with :d, anything else is a search word.",
"                   : Precede term with - to exclude e.g.  -@Computer",
"                   : e.g LIST @computer or LIST #5",
"@                  : sorted list by Context.",
":D                 : sorted list by Dates",
":P                 : sorted list by Projects",
"LIST&gt;/L&gt; [filter]  : standard list sent to an HTML report",
"@&gt;                 : sorted list by Context sent to an HTML report",
":D&gt;                : sorted list by Dates sent to an HTML report",
":P&gt;                : sorted list by Projects sent to an HTML report",
"                   : The HTML reports are sent to todoFilename.html",
"!PAUSE!",
"ADVANCED OPTIONS",
"----------------",
"The SETEDxxx commands allow you to use an external editor.",
"Note the editor you pick should be a simple text editor.  If you pick",
"something that doesn't work, try the defaults again.",
"Because some systems may have different editors installed, you can set",
"more than one by separating the editors usng commas.  The program will",
"use the first one it finds.",
"For Windows the default is edit, which works quite well in the terminal",
"but you could change it to notepad.",
"For Linux, the default is nano,pico,vim,emacs.",
"To use external editors you must switch on system calls using the SYS ON",
"command",
"SETEDNT command    : Set the external editor for Windows (NT).",
"SETEDPOSIX command : Set the editor for posix systems.",
"                   : e.g. SETEDNT edit",
"                   :      SETEDPOSIX nano,vim",
"SHORTCUT/SC ?      : list shortcuts",
"SHORTCUT/SC N cmd  : Set shortcut N to command cmd",
"=N                 : Run shortcut N",
"!PAUSE!",
"ABBREV/AB @x @full : Create new abbreviation. @x expands to @full",
"ABBREV/AB ?        : List context abbreviations.",
"PAB :px :pfull     : Project abbreviation. :px expands to :pfull",
"PAB ?              : List project abbreviations.",
"!PAUSE!",
"ENTERING TASKS",
"--------------",
"When you enter a task, you can embed any number of contexts in the task.",
"You can also embed a project description by preceding it with :p",
"You can assign a priority by preceding a number by #.  e.g. #9.",
"If you don't enter a number, a default of 5 is used.  The higher the ",
"number the more important it is. Priorities range from 1 to 10.",
"Only the first # is used for the priority so you can use # as",
"a normal character as long as you precede it with a priority number.",
"You can define a date when the task must be done by preceding the date",
"with :d, i.e :dYYYY/MM/DD or :dMM/DD or :dDD. If you omit the year/month",
"they default to the current date. Adding a date automatically creates an",
"@Date context for the task.",
"So, for example, to add a new task to e-mail Joe, we could enter:",
"+ e-mail joe @computer",
"or to add a task to the decorating project, we could enter:",
"+ buy wallpaper :pdecorating",
"to enter a task with an importance of 9 we could enter:",
"+ book that holiday #9 @Internet",
"!PAUSE!",
"MODIFYING AND EXTENDING TASKS",
"-----------------------------",
"The modify command allows you to change part of an existing task.",
"So for example, imagine you have a task:",
"[05] Buy some food #9 @Internet Projects:Shopping",
"Enter the command M 5 and then type:",
"@C",
"Because the only element we have entered is a new context, only",
"that part is modified, so we get.",
"[05] Buy some food #9 @Computer Projects:Shopping",
"Likewise, had we entered:",
"Buy some tea :pEating",
"We would have got",
"[05] Buy some tea #9 @Internet Projects:Eating",
"The extend command is similar but it appends the entry. So had",
"we used the command E 5 instead of M 5 the result would have been",
"[05] Buy some food ... Buy some tea #9 @Internet Projects:Eating",
"!PAUSE!",
"CONTEXTS",
"--------",
"Any word preceded by @ will be used as a context.  Contexts are like",
"sub-categories or sub-lists.  There are a number of pre-defined",
"abbreviations that you can use as well. The recognised abbreviations",
"are:",
"@A = @Anywhere (this is the default)",
"@C = @Computer",
"@D = @Desk",
"@E = @Errands",
"@H = @Home",
"@I = @Internet",
"@L = @Lunch",
"@M = @Meeting",
"@N = @Next",
"@O = @Other",
"@P = @Phone",
"@PW= @Password",
"@S = @Someday/maybe",
"@W4= @Waiting_for",
"@W = @Work",
"!PAUSE!",
"ENTERING DATES",
"--------------",
"An @Date context is created if you embed a date in the task.",
"Dates are embedded using the :dDATE format.",
"Valid DATE formats are yyyy-mm-dd, mm-dd or dd",
"You can also use : or / as the separators.  So, for example:",
":d2006/12/22 or :d2006-11-7 or :d9/28 are all valid entries.",
"",
"If you set a date, then until that date is reached, the task is given",
"an effective priority of 0.  Once the date is reached, the task's",
"priority is increased by 11, moving it to the of the list.",
"",
"A date entry of :d0 can be used to clear a date entry.",
"A date entry of :d+X can be used to create a date entry of today + X days.",
"So :d+1 is tomorrow and :d+0 is today.",
"!PAUSE!",
"ENCRYPTING TEXT",
"---------------",
"If you want to encrypt text you can use the &lt;private&gt; or &lt;secret&gt; tags or",
"their abbreviations &lt;p&gt; and &lt;s&gt;.",
"These tags will result in all text following the tag to be encrypted.",
"Note that any special commands, @contexts for example, are treated as plain",
"text in the encrypted portion.",
"To display the text you will need to use the SHOW command.",
"",
"The &lt;private&gt; tag uses the inbuilt XTEA algorithm.  This is supposedly a",
"relatively secure method but probably not suitable for very sensitive data.",
"",
"The &lt;secret&gt; tag can only be used if you have the pyRijndael.py module.",
"This uses a 256 bit Rinjdael cipher.  The module can be downloaded from ",
"http://jclement.ca/software/pyrijndael/",
"You can install this in your Python path or just place it alongside your",
"ikog file.",
"Note you cannot use the extend command with encrypted text.",
"",
"!PAUSE!",
"MARKING TASKS AS COMPLETE",
"-------------------------",
"The normal way to mark a task as complete is just to remove it using the",
"KILL command.  If you want to keep track of tasks you have finished, you",
"can use the ARCHIVE or DONE command.  This gives the task an @Archived",
"context, changes the date to today and then moves it from the current",
"file to a file with archive.dat appended.  The archive file is a valid",
"ikog file so you can use the OPEN command to view it, edit it and run",
"reports in the normal way.  So assuming your current script is ikog.py,",
"to archive the current task you could enter:",
"",
"ARCHIVE ^ I have finished this",
"",
"This would move the task to a file called ikog.py.archive.dat",
"",
"!PAUSE!",
"USING EXTERNAL DATA",
"-------------------",
"Normally the tasks are embedded in the main program file so all you have",
"to carry around with you is the ikog.py file.  The advantage is that you",
"only have one file to look after; the disadvantage is that every time you",
"save a task you have to save the program as well.  If you want, you can",
"keep your tasks in a separate file.",
"To do this, use the EXPORT function to create a file ikog.py.tasks.txt",
"Use the CLEAR command to remove the tasks from your main ikog.py program.",
"Rename the exported file from ikog.py.tasks.txt to ikog.py.dat",
"Ikog will now use this file for storing your tasks.",
"",
"!PAUSE!",
"PASSING TASKS VIA THE COMMAND LINE",
"----------------------------------",
"It is possible to add tasks via the command line. The general format of",
"the command line is:",
"   ikog.py filename commands",
"The filename is the name of the data file containing your tasks.  You",
"can use . to represent the default internal tasks.",
"Commands is a set of normal ikog commands separated by the / ",
"character. Note there must be a space either side of the /.",
"So to add a task and then exit the program we could just enter:",
"   ikog.py . + here is my task / QUIT",
"Note that we added the quit command to exit ikog.",
"You must make sure that you do not use any commands that require user",
"input.  Deleting tasks via the command line is more complicated as you",
"need to find the task automatically.  If you do try to delete this way,",
"use the filter command to find some unique text and then delete it. eg.",
"   ikog.py . FI my_unique_text / KILL THIS / QUIT",
"Use THIS instead of ^ as a caret has a special meaning in Windows.",
"If you do intend automating ikog from the command line, you should add",
"a unique reference to each task so you can find it later using FILTER. eg.",
"+ this is my task ref_1256",
"!PAUSE!"]

MOVE_DOWN = 0
MOVE_UP = 1
MOVE_TOP = 2
MAX_SHORTCUTS = 10

</t>
<t tx="BIGZHU.20070802223007.62">def __init__(self, todoFile, externalDataFile):
    self.setShortcuts()
    self.dirty = False
    self.code = []
    self.todo = []
    self.autoSave = True
    self.review = True
    self.sysCalls = False
    self.currentTask = 0
    self.globalFilterText = ""
    self.globalFilters = []
    self.localFilterText = ""
    self.localFilters = []
    # split the file into the source code and the todo list
    self.filename = todoFile
    try:
        self.filename = os.readlink(todoFile)
    except Exception:
        pass # probably windows
    externalDataFile = self.makeFilename(externalDataFile)
    self.externalData = self.findDataSource(externalDataFile)
    if self.externalData:
        self.filename = externalDataFile
    else:
        self.splitFile(self.filename, False)
    self.exactPriority = False
    self.htmlFile = ""
</t>
<t tx="BIGZHU.20070802223007.63">def setPAbbreviation(self, line):
    save = False
    elements = line.split(" ", 1)
    if not elements[0].lower().startswith(":p"):
        self.showError("Project abbreviations must begin with :p")
    elif len(elements) &gt; 1:
        if not elements[1].lower().startswith(":p"):
            abb = ":p" + elements[1].title()
        else:
            abb = ":p" +elements[1][2:].title()
        globalPAbbr.addAbbreviation(elements[0], abb)
        save = True
    else:
        if not globalPAbbr.removeAbbreviation(elements[0]):
            self.showError("Could not find project abbreviation " + line)
        else:
            print "Project abbreviation ", line, " removed."
            save = True
    return save
</t>
<t tx="BIGZHU.20070802223007.64">def showPAbbreviations(self):
    print globalPAbbr.toStringVerbose()
</t>
<t tx="BIGZHU.20070802223007.65">def setAbbreviation(self, line):
    save = False
    elements = line.split(" ", 1)
    if not elements[0].startswith("@"):
        self.showError("Abbreviations must begin with @")
    elif len(elements) &gt; 1:
        if not elements[1].startswith("@"):
            abb = "@" + elements[1].title()
        else:
            abb = "@" +elements[1][1:].title()
        globalAbbr.addAbbreviation(elements[0], abb)
        save = True
    else:
        if not globalAbbr.removeAbbreviation(elements[0]):
            self.showError("Could not find abbreviation " + line)
        else:
            print "Abbreviation ", line, " removed."
            save = True
    return save
</t>
<t tx="BIGZHU.20070802223007.66">def showAbbreviations(self):
    print globalAbbr.toStringVerbose()
</t>
<t tx="BIGZHU.20070802223007.67">def setShortcut(self, line, force = False):
    elements = line.split(" ", 1)
    try:
        index = int(elements[0])
        if len(elements) &gt; 1:
            command = elements[1]
        else:
            command = ""
    except Exception, e:
        self.showError("Did not understand the command.  Format should be SHORTCUT N my command.")
        return False

    if index &lt; 0 or index &gt; len(self.shortcuts):
        self.showError("The maximum number of shortcuts is " + str(len(self.shortcuts)) + ". Shortcuts ignored.")
        return False
    else:
        if self.shortcuts[index] != "" and not force:
            if safeRawInput("Do you want to change the current command '" + self.shortcuts[index] + "'? Enter Yes to overwrite. &gt;&gt;&gt;").upper() != "YES":
                return False
        self.shortcuts[index] = command
        return True
</t>
<t tx="BIGZHU.20070802223007.68">def showShortcuts(self):
    index = 0
    for s in self.shortcuts:
        if s == "":
            msg = "unused"
        else:
            msg = s
        print "=%1d %s" %(index, msg)
        index = index + 1
</t>
<t tx="BIGZHU.20070802223007.69">def setShortcuts(self, settings = []):
    if len(settings) &gt; self.MAX_SHORTCUTS:
        self.showError("The maximum number of shortcuts is " + str(self.MAX_SHORTCUTS) + ". Shortcuts ignored.")
    self.shortcuts = ["" for n in range(self.MAX_SHORTCUTS)]
    if len(settings) &gt; 0:
        self.shortcuts[0:len(settings)] = settings
</t>
<t tx="BIGZHU.20070802223007.70">def getShortcutIndex(self, command):
    if len(command) == 2 and command[0:1].upper() == "=":
        index = ord(command[1]) - ord("0")
        if index &gt;= self.MAX_SHORTCUTS:
            index = -1
    else:
        index = -1
    return index
</t>
<t tx="BIGZHU.20070802223007.71">def getShortcut(self, command):
    index = self.getShortcutIndex(command)
    if index &gt;= 0:
        return self.shortcuts[index]
    else:
        return ""
</t>
<t tx="BIGZHU.20070802223007.72">def safeSystemCall(self, line):
    words = line.split()
    if len(words) == 0:
        self.showError("Nothing to do.")
    elif words[0].upper() == "RM" or words[0].upper() == "RMDIR" or words[0].upper() == "DEL":
        self.showError("Sorry, but deletion commands are not permitted.")
    else:
        os.system(line)
        self.pause()
</t>
<t tx="BIGZHU.20070802223007.73">def processCfgLine(self, line):
    params = line.split("=")
    if len(params) &lt; 2:
        return
    cmd = params[0].strip()
    if cmd == "cfgEditorNt":
        global cfgEditorNt
        cfgEditorNt = params[1].replace("\"", "").strip()
    elif cmd == "cfgEditorPosix":
        global cfgEditorPosix
        cfgEditorPosix = params[1].replace("\"", "").strip()
    elif cmd == "cfgShortcuts":
        elements = params[1].strip()[1:-1].split(",")
        index = 0
        for e in elements:
            self.setShortcut(str(index) + " " + e.strip()[1:-1], True)
            index = index + 1
    elif cmd == "cfgAutoSave":
        if params[1].upper().strip() == "TRUE":
            as = True
        else:
            as = False
        self.setAutoSave(as, False)
    elif cmd == "cfgReviewMode":
        if params[1].upper().strip() == "TRUE":
            self.setReview("ON")
        else:
            self.setReview("OFF")
    elif cmd == "cfgSysCalls":
        if params[1].upper().strip() == "TRUE":
            self.setSysCalls("ON")
        else:
            self.setSysCalls("OFF")
    elif cmd == "cfgColor":
        gColor.setCodeSet(int(params[1].strip()))
    elif cmd == "cfgAbbreviations":
        abbrs = eval(params[1].strip())
        globalAbbr.setAbbreviations(abbrs)
    elif cmd == "cfgPAbbreviations":
        abbrs = eval(params[1].strip())
        globalPAbbr.setAbbreviations(abbrs)
    else:
        self.showError("Unrecognised command "  + cmd)
</t>
<t tx="BIGZHU.20070802223007.74">def makeFilename(self, name):
    (root, ext) = os.path.splitext(name)
    if ext.upper() != ".DAT":
        name = name + ".dat"
    try:
        name = os.path.expanduser(name)
    except Exception, e:
        self.showError("Failed to expand path. " + str(e))
    return name
</t>
<t tx="BIGZHU.20070802223007.75">def findDataSource(self, filename):
    success = False

    try:
        self.splitFile(filename, False)
        print "Using external data file ", filename
        success = True
    except IOError:
        print "No external data file ", filename, ", so using internal tasks."
    return success
</t>
<t tx="BIGZHU.20070802223007.76">def setSysCalls(self, mode):
    oldCalls = self.sysCalls
    mode = mode.strip().upper()
    if mode == "ON":
        self.sysCalls = True
        print "Using system calls for clear screen"
    elif mode == "OFF":
        self.sysCalls = False
        print "No system calls for clear screen"
    else:
        self.showError("Could not understand the sys command.  Use SYS ON or OFF.")
    return (self.sysCalls != oldCalls)
</t>
<t tx="BIGZHU.20070802223007.77">def setAutoSave(self, as, save):
    if as:
        if self.autoSave == False:
            self.autoSave = True
            if save:
                self.save("")
    elif self.autoSave == True:
        self.autoSave = False
        if save:
            self.save("")
    if self.autoSave:
        print "Autosave is on."
    else:
        print "Autosave is off."
</t>
<t tx="BIGZHU.20070802223007.78">def showError(self, msg):
    printError(msg)
</t>
<t tx="BIGZHU.20070802223007.79">def pause(self, prompt = "Press enter to continue."):
    if safeRawInput(prompt).strip() != "":
        print "Entry ignored!"
</t>
<t tx="BIGZHU.20070802223007.80">def setReview(self, mode):
    oldReview = self.review
    mode = mode.strip().upper()
    if mode == "ON":
        self.review = True
        print "In review mode.  Enter advances to the next task"
    elif mode == "OFF":
        self.review = False
        print "Review mode off.  Enter re-displays the current task"
    else:
        self.showError("Could not understand the review command.  Use REVIEW ON or OFF.")
    return (self.review != oldReview)
</t>
<t tx="BIGZHU.20070802223007.81">def sortByPriority(self):
    self.todo.sort(key=TodoItem.getEffectivePriority, reverse = True)
</t>
<t tx="BIGZHU.20070802223007.82">def run(self, commandList):
    if not supportAes:
        print "AES encryption not available."
    print("\nEnter HELP for instructions.")

    done = False
    printCurrent = True
    self.sortByPriority()
    reopen = ""
    enteredLine = ""
    truncateTask = False
    while not done:
        self.checkCurrentTask()
        if printCurrent:
            self.moveToVisible()
            print ruler
            if truncateTask:
                self.printItemTruncated(self.currentTask, "Current: ")
            else:
                self.printItemVerbose(self.currentTask)
            print ruler
        printCurrent= True
        truncateTask = False
        if self.dirty:
            prompt = "!&gt;&gt;"
        else:
            prompt = "&gt;&gt;&gt;"
        if len(commandList) &gt;= 1:
            enteredLine = commandList[0]
            commandList = commandList[1:]
            print enteredLine
        (rawcommand, line) = InputParser(prompt).read(enteredLine)
        enteredLine = ""
        command = rawcommand.upper()
        if self.getShortcutIndex(command) &gt;= 0:
            sc = self.getShortcut(command)
            if sc != "":
                (rawcommand, line) = InputParser("").read(self.getShortcut(command))
            else:
                rawcommand = ""
                line = ""
                continue
            print "Shortcut: ", rawcommand, " ", line
        command = rawcommand.upper()
        if command == "":
            if self.review:
                self.incTaskLoop()
        elif command == "PAB":
            if line.strip() == "?":
                self.showPAbbreviations()
            elif self.setPAbbreviation(line):
                self.save("")
        elif command == "ABBREV" or command == "AB":
            if line.strip() == "?":
                self.showAbbreviations()
            elif self.setAbbreviation(line):
                self.save("")
        elif command == "SHORTCUT" or command == "SC":
            if line.strip() == "?":
                self.showShortcuts()
            else:
                if self.setShortcut(line):
                    self.save("")
            printCurrent = False
        elif command == "2":
            enteredLine = self.runTimer(2)
            printCurrent = False
        elif command == "CLS" or command == "CLEARSCREEN":
            clearScreen(self.sysCalls)
        elif command == "SETEDNT":
            global cfgEditorNt
            cfgEditorNt = line
            self.save("")
        elif command == "SETEDPOSIX":
            global cfgEditorPosix
            cfgEditorPosix = line
            self.save("")
        elif command == "SYS":
            if self.setSysCalls(line):
                self.save("")
        elif command == "!CMD":
            if self.sysCalls:
                self.safeSystemCall(line)
            else:
                self.showError("System calls are not allowed.  Use SYS ON to enable them.")
        elif command == "SHOW" or command == "SH":
            self.decrypt(line)
            self.pause("Press enter to clear screen and continue. ")
            clearScreen(self.sysCalls)
        elif command == "VERSION" or command == "VER":
            print notice[0]
        elif command == "SAVE" or command == "S":
            if not self.dirty:
                print "There's no need to save now.  If the prompt shows &gt;&gt;&gt; "
                print "then there is nothing to save.  You only need to save if the prompt "
                print "shows !&gt;&gt;"
            else:
                self.forceSave("")
        elif command == "NEW":
            filename = self.makeFilename(line)
            if self.createFile(filename):
                reopen = filename
                if self.dirty:
                    self.forceSave("")
                done = True
            printCurrent = False
        elif command == "OPEN" or command == "O":
            filename = self.makeFilename(line)
            reopen = filename
            if self.dirty:
                self.forceSave("")
            done = True
            printCurrent = False
        elif command == "AUTOSAVE" or command == "AS":
            if line== "":
                self.showError("You must enter ON or OFF for the autosave command")
            else:
                self.setAutoSave(line.upper() == "ON", True)
        elif command == "REVIEW" or command == "REV":
            if self.setReview(line):
                self.save("")
        elif command == "V0":
            if self.setReview("OFF"):
                self.save("")
        elif command == "V1":
            if self.setReview("ON"):
                self.save("")
        elif command == "?":
            self.printHelp(self.quickCard)
        elif command == "HELP" or command == "H":
            self.printHelp(self.help)
        elif command == "QUIT" or command == "Q":
            if self.dirty:
                self.forceSave("")
            done = True
            printCurrent = False
        elif command == "WEB":
            try:
                webbrowser.open("http://www.henspace.co.uk")
            except Exception, e:
                self.showError("Unable to launch browser. " + str(e))
        elif command == "COLOR" or command == "COLOUR" or command == "C":
            try:
                set = int(line, 10)
            except ValueError:
                set = gColor.ANSI
            if not gColor.isValidSet(set):
                self.showError("Invalid colour set ignored.")
            elif gColor.setCodeSet(set):
                self.save("")
        elif command == "MONOCHROME" or command == "MONO":
            if gColor.setCodeSet(gColor.NONE):
                self.save("")
        elif command == "EXPORT":
            self.exportTasks()
        elif command == "IMPORT":
            if self.importTasks(line):
                self.save("")
        elif command == "CLEAR" and line == "":
            if self.clear():
                self.save("")
        elif command == "FILTER" or command == "FI" or command == "=":
            self.setFilterArray(False, line)
        elif command == "NEXT" or command == "N":
            self.incTaskLoop()
        elif command == "PREV" or command == "P":
            self.decTaskLoop()
        elif command == "TOP" or command == "T" or command == "0":
            self.currentTask = 0
            if line != "":
                self.setFilterArray(True, "")
                self.showLocalFilter()
                self.printShortList(line)
                truncateTask = True
        elif command == "GO" or command == "G":
            self.moveTo(line)
        elif command == "IMMEDIATE" or command == "I" or command == "++":
            newItem = self.createItem(":d+0 " + line)
            if newItem.hasHiddenTask():
                clearScreen(self.sysCalls)
            if newItem.hasError():
                print "Errors were found:"
                print newItem.getError()
                print "The task was not added."
                printCurrent = False
            else:
                self.todo.insert(0, newItem)
                self.currentTask = 0
                self.sortByPriority()
                self.save("")
        elif command == "KILL" or command == "K" or command == "-" or command == "X":
            if self.removeTask(line):
                self.save("")
        elif command == "ARCHIVE" or command == "DONE":
            if self.archiveTask(line):
                self.save("")
        elif command == "REP" or command =="R":
            if self.modifyTask(line, TodoItem.REPLACE):
                self.sortByPriority()
                self.save("")
            else:
                printCurrent = False
        elif command == "SUB" or command == "SU":
            if self.substituteText(line):
                self.sortByPriority()
                self.save("")
        elif command == "EDIT" or command == "ED":
            if not self.sysCalls:
                self.showError("External editing needs to use system calls.  Use SYS ON to enable them.")
            elif line == "":
                self.addTaskExternal()
            elif self.modifyTask(line, TodoItem.MODIFY, externalEditor = True):
                self.sortByPriority()
                self.save("")
            else:
                printCurrent = False
        elif command == "MOD" or command == "M":
            if self.modifyTask(line, TodoItem.MODIFY):
                self.sortByPriority()
                self.save("")
            else:
                printCurrent = False
        elif command == "EXTEND" or command == "E":
            if self.modifyTask(line, TodoItem.APPEND):
                self.sortByPriority()
                self.save("")
            else:
                printCurrent = False
        elif command == "FIRST" or command == "F":
            if self.moveTask(line, self.MOVE_TOP):
                self.sortByPriority()
                self.save("")
                self.currentTask = 0
        elif command == "DOWN" or command == "D":
            if self.moveTask(line, self.MOVE_DOWN):
                self.sortByPriority()
                self.save("")
        elif command == "UP" or command == "U":
            if self.moveTask(line, self.MOVE_UP):
                self.sortByPriority()
                self.save("")
        elif command == "LIST" or command == "L":
            print ruler
            self.setFilterArray(True, line)
            self.showLocalFilter()
            self.printList(False, "", "")
            self.clearFilterArray(True)
            print ruler
            truncateTask = True
        elif command == "LIST&gt;" or command == "L&gt;":
            self.startHtml("")
            self.setFilterArray(True, line)
            self.showLocalFilter()
            self.printList(False, "", "")
            self.clearFilterArray(True)
            self.endHtml()
        elif command == "@":
            self.listByAction()
            truncateTask = True
        elif command == ":P":
            self.listByProject()
            truncateTask = True
        elif command == ":D":
            self.listByDate()
            truncateTask = True
        elif command == "@&gt;":
            self.startHtml("Report by Context")
            self.listByAction()
            self.endHtml()
        elif command == ":P&gt;":
            self.startHtml("Report by Project")
            self.listByProject()
            self.endHtml()
        elif command == ":D&gt;":
            self.startHtml("Report by Date")
            self.listByDate()
            self.endHtml()
        elif command == "ADD" or command == "A" or command == "+":
            self.addTask(line)
        elif command == "NOTE" or command == "NOTES":
            self.addTask("#0 @Notes " + line)
        elif (len(command) + len(line)) &gt; 10:
            self.addTask(rawcommand + " " + line)
        elif len(command) &gt; 0:
            self.showError("Didn't understand. (Make sure you have a space after the command or your entry is longer than 10 characters)")
            printCurrent = False
    return reopen
</t>
<t tx="BIGZHU.20070802223007.83">def timeout(self):
    self.timerActive = False
    clearScreen()
    print "\n\x07Timer\x07 complete.\x07\n\x07Press enter to continue.\x07"
</t>
<t tx="BIGZHU.20070802223007.84">def runTimer(self, delay):
    self.timerActive = True
    t = Timer(delay * 60 , self.timeout)
    t.start()
    s = raw_input(str(delay) + " minute timer running.\nAny entry will cancel the timer:\n&gt;&gt;&gt;")
    if self.timerActive:
        t.cancel()
        print "Timer cancelled."
    elif s != "":
        s = ""
        print "Input discarded as timer has finished."
    return s.strip()
</t>
<t tx="BIGZHU.20070802223007.85">def addTaskExternal(self):
    exEdit = EditorLauncher()
    entry = exEdit.edit("")
    if entry != "":
        self.addTask(entry)
    else:
        self.showError("Nothing to add")
</t>
<t tx="BIGZHU.20070802223007.86">def addTask(self, line):
    newItem = self.createItem(line)
    if newItem.hasError():
        print "Errors were found:"
        print newItem.getError()
        print "The task was not added."
        printCurrent = False
    else:
        if newItem.hasHiddenTask():
            clearScreen(self.sysCalls)
        self.todo.append(newItem)
        self.sortByPriority()
        self.save("")
</t>
<t tx="BIGZHU.20070802223007.87">def checkCurrentTask(self):
    if self.currentTask &gt; len(self.todo) - 1:
        self.currentTask = len(self.todo) - 1
    if self.currentTask &lt; 0:
        self.currentTask = 0
</t>
<t tx="BIGZHU.20070802223007.88">def writeArchive(self, item):
    success = False
    filename = self.filename + ".archive.dat"
    try:
        if not os.path.exists(filename):
            f = open(filename,"wb")
            f.write("# " + notice[0] + "\n")
            f.write(magicTag + "DATA\n")
        else:
            f = open(filename,"a+b")

        f.write(item.toString())
        f.write("\n")
        f.close()
        print "Tasks archived to " + filename
        success = True
    except Exception, e:
        self.showError("Error trying to archive the tasks.\n" + str(e))
    return success
</t>
<t tx="BIGZHU.20070802223007.89">def exportTasks(self):
    filename = self.filename + ".tasks.txt"
    try:
        f = open(filename,"wb")
        f.write("# " + notice[0] + "\n")
        f.write(magicTag + "DATA\n")
        for item in self.todo:
            f.write(item.toString())
            f.write("\n")
        f.close()
        print "Tasks exported to " + filename
    except Exception, e:
        self.showError("Error trying to export the file.\n" + str(e))
</t>
<t tx="BIGZHU.20070802223007.90">def importTasks(self, filename):
    success = False
    orgNTasks = len(self.todo)
    if filename == "":
        self.showError("You must supply the name of the file to import.")
        return success

    try:
        self.splitFile(filename, True)
        if len(self.todo) == orgNTasks:
            self.showError("Failed to find any tasks to import.")
        else:
            success = True
    except Exception, e:
        self.showError("Error importing tasks. " + str(e))
    return success
</t>
<t tx="BIGZHU.20070802223007.91">def createFile(self, filename):
    success = False
    if os.path.exists(filename):
        self.showError("Sorry but " + filename + " already exists.")
    else:
        try:
            f = open(filename, "wb")
            f.write("#!/usr/bin/env python\n")
            f.write("#" + ruler + "\n")
            f.close()
            success = True
        except Exception, e:
            self.showError("Error trying to create the file " + filename + ". " + str(e))
    return success
</t>
<t tx="BIGZHU.20070802223007.92">def save(self, filename):
    if filename != "" or self.autoSave:
        self.forceSave(filename)
    else:
        self.dirty = True
        print "Autosave is off, so changes not saved yet."
</t>
<t tx="BIGZHU.20070802223007.93">def forceSave(self, filename):
    if filename == "":
        filename = self.filename
    tmpFilename = filename + ".tmp"
    backupFilename = filename + ".bak"
    success = False
    try:
        f = open(tmpFilename,"wb")
        f.write("#!/usr/bin/env python\n")
        f.write("# -*- coding: utf-8 -*-\n")
        f.write("#" + ruler + "\n")
        f.write("# Run the script for details of the licence\n")
        f.write("# or refer to the notice section later in the file.\n")
        f.write("#" + ruler + "\n")
        f.write(magicTag + "DATA\n")
        for item in self.todo:
            f.write(item.toString())
            f.write("\n")
        f.write(magicTag + "CONFIG\n")
        f.write("cfgColor = " + str(gColor.getCodeSet()) + "\n")
        f.write("cfgAutoSave = " + str(self.autoSave) + "\n")
        f.write("cfgReviewMode = " + str(self.review) + "\n")
        f.write("cfgSysCalls = " + str(self.sysCalls) + "\n")
        f.write("cfgEditorNt = \"" + cfgEditorNt + "\"\n")
        f.write("cfgEditorPosix = \"" + cfgEditorPosix + "\"\n")
        f.write("cfgShortcuts = " + str(self.shortcuts) + "\n")
        f.write("cfgAbbreviations = " +str(globalAbbr.toString()) +"\n")
        f.write("cfgPAbbreviations = " +str(globalPAbbr.toString()) +"\n")
        f.write(magicTag + "CODE\n")
        for codeline in self.code:
            f.write(codeline.rstrip())
            f.write("\n")
        f.close()
        success = True

    except Exception, e:
        self.showError("Error trying to save the file.\n" + str(e))
    if success:
        try:
            os.remove(backupFilename)
        except Exception:
            pass
        try:
            oldstat = os.stat(filename)
            os.rename(filename, backupFilename)
            os.rename(tmpFilename, filename)
            os.chmod(filename, stat.S_IMODE(oldstat.st_mode)) # ensure permissions carried over
            self.filename = filename
            self.dirty = False
            print "Tasks saved."
        except Exception, e:
            self.showError("Error trying to rename the backups.\n" + str(e))
</t>
<t tx="BIGZHU.20070802223007.94">def moveTo(self, indexStr):
    try:
        index = int(indexStr, 10)
        if index &lt; 0 or index &gt; len(self.todo) - 1:
            self.showError("Sorry but there is no task " + indexStr)
        else:
            if not self.isViewable(self.todo[index]):
                print "Switching off your filter so that the task can be displayed."
                self.clearFilterArray(False)
            self.currentTask = index
    except ValueError:
        self.showError("Unable to understand the task " + indexStr + " you want to show.")
</t>
<t tx="BIGZHU.20070802223007.95">def moveToVisible(self):
    start = self.currentTask
    find = True
    if start &lt; 0 or start &gt;= len(self.todo):
        return
    while not self.isViewable(self.todo[self.currentTask]):
        self.incTaskLoop()
        if self.currentTask == start:
            print "Nothing matched your filter.  Removing your filter so that the current task can be displayed."
            self.clearFilterArray(False)
            break
</t>
<t tx="BIGZHU.20070802223007.96">def decrypt(self, indexStr):
    index = self.getRequiredTask(indexStr)
    if index &lt; 0 or index &gt; len(self.todo) - 1:
        self.showError("Sorry but there is no task " + indexStr + " to show.")
    elif self.todo[index].hasHiddenTask():
        ec = Encryptor()
        print WordWrapper(gMaxLen).wrap(ec.enterKeyAndDecrypt(self.todo[index].getHiddenTask()))
    else:
        print "Task ", index, " has no encrypted data."
</t>
<t tx="BIGZHU.20070802223007.97">def moveTask(self, indexStr, where):
    success = False
    if indexStr == "":
        print "You must supply the number of the task to move."
        return False
    try:
        index = self.getRequiredTask(indexStr)
        if index &lt; 0 or index &gt; len(self.todo) - 1:
            self.showError("Sorry but there is no task " + indexStr + " to move.")
        elif where == self.MOVE_DOWN:
            if index &lt;= len(self.todo) - 2:
                item = self.todo[index]
                self.todo[index] = self.todo[index + 1]
                self.todo[index + 1] = item
                print "Task ", index, " moved down."
                success = True
            else:
                self.showError("Task " + str(index) + " is already at the bottom.")
        else:
            if index &gt; 0:
                if where == self.MOVE_TOP:
                    self.todo.insert(0, self.todo.pop(index))
                else:
                    dest = index - 1
                    item = self.todo[dest]
                    self.todo[dest] = self.todo[index]
                    self.todo[index] = item
                print "Task ", index, " moved up."
                success = True
            else:
                self.showError("Task " + str(index) + " is already at the top.")


    except ValueError:
        self.showError("Unable to understand the task " + indexStr + " you want to move.")

    return success
</t>
<t tx="BIGZHU.20070802223007.98">def clear(self):
    cleared = False
    if safeRawInput("Are you really sure you want to remove everything? Yes or No? &gt;&gt;&gt;").upper() != "YES":
        print("Nothing has been removed.")
    else:
        del self.todo[0:]
        self.currentTask = 0
        cleared = True
    return cleared
</t>
<t tx="BIGZHU.20070802223007.99">def getRequiredTask(self, indexStr):
    if indexStr == "^" or indexStr.upper() == "THIS":
        index = self.currentTask
    else:
        try:
            index = int(indexStr, 10)
        except ValueError:
            index = -1
    return index
</t>
<t tx="BIGZHU.20070802223007.100">def archiveTask(self, indexStr):
    doit = False
    line = indexStr.split(" ", 1)
    if len(line) &gt; 1:
        indexStr = line[0]
        entry = line[1]
    else:
        entry = ""
    index = self.getRequiredTask(indexStr)
    if index &lt; 0 or index &gt; len(self.todo) - 1:
        self.showError("Sorry but there is no task " + indexStr + " to mark as done and archive.")
    else:
        if indexStr == "^" or indexStr.upper() == "THIS":
            doit = True
        else:
            print "Are you sure you want to archive: ' " + self.todo[index].toStringSimple() + "'"
            if safeRawInput("Enter Yes to archive this task? &gt;&gt;&gt;").upper() == "YES":
                doit = True
        if doit:
            newItem = self.createItem(":d+0")
            self.todo[index].copy(newItem, TodoItem.MODIFY)
            newItem = self.createItem(entry + " @Archived")
            self.todo[index].copy(newItem, TodoItem.APPEND)
            if self.writeArchive(self.todo[index]):
                self.todo[index:index + 1] = []
                print "Task ", index, " has been archived."
            else:
                doit = False
                print "Task ", index, " marked as archived but not removed."
        else:
            print "Task ", index, " has not been archived."
    return doit
</t>
<t tx="BIGZHU.20070802223007.101">def removeTask(self, indexStr):
    doit = False
    index = self.getRequiredTask(indexStr)
    if index &lt; 0 or index &gt; len(self.todo) - 1:
        self.showError("Sorry but there is no task " + indexStr + " to delete.")
    else:
        if indexStr == "^" or indexStr.upper() == "THIS":
            doit = True
        else:
            print "Are you sure you want to remove ' " + self.todo[index].toStringSimple() + "'"
            if safeRawInput("Enter Yes to delete this task? &gt;&gt;&gt;").upper() == "YES":
                doit = True
        if doit:
            self.todo[index:index + 1] = []
            print "Task ", index, " has been removed."
        else:
            print "Task ", index, " has not been removed."
    return doit
</t>
<t tx="BIGZHU.20070802223007.102">def substituteText(self, indexStr):
    line = indexStr.split(" ", 1)
    if len(line) &gt; 1:
        indexStr = line[0]
        entry = line[1]
    else:
        self.showError("You need to define the task and substitution phrases. e.g SUB 0 /old/new/")
        return False


    success = False
    if indexStr == "":
        print "You must supply the number of the task to change."
        return False

    index = self.getRequiredTask(indexStr)

    if index &lt; 0 or index &gt; len(self.todo) - 1:
        self.showError("Sorry but there is no task " + indexStr)
    else:
        text = entry.replace("/", "\n")
        text = text.replace("\\\n","/")
        phrases = text.split("\n")
        if len(phrases) != 4:
            self.showError("The format of the command is incorrect.  The substitution phrases should be /s1/s2/ ")
            return False
        oldText = self.todo[index].getTask()
        newText = oldText.replace(phrases[1], phrases[2])
        if newText == oldText:
            self.showError("Nothing has changed.")
            return False
        newItem = self.createItem(newText)
        if newItem.hasError():
            print "With the substitution the task had errors:"
            print newItem.getError()
            print "Task ", index, " is unchanged."
        else:
            if newItem.hasHiddenTask():
                clearScreen(self.sysCalls)
                self.showError("It isn't possible to create private or secret data by using the substitition command.")
            else:
                self.todo[index].copy(newItem, TodoItem.MODIFY)
                print "Task ", index, " has been changed."
                success = True
    return success
</t>
<t tx="BIGZHU.20070802223007.103">def modifyTask(self, indexStr, replace, externalEditor = False):
    line = indexStr.split(" ", 1)
    if len(line) &gt; 1:
        indexStr = line[0]
        entry = line[1]
    else:
        entry = ""

    success = False
    if indexStr == "":
        print "You must supply the number of the task to change."
        return

    index = self.getRequiredTask(indexStr)

    if index &lt; 0 or index &gt; len(self.todo) - 1:
        self.showError("Sorry but there is no task " + indexStr)
    else:
        if entry == "":
            if externalEditor:
                exEdit = EditorLauncher()
                (key, entry) = self.todo[index].toStringEditable()
                entry = exEdit.edit(entry)
            else:
                if replace == TodoItem.REPLACE:
                    print "This task will completely replace the existing entry,"
                    print "including any projects and actions."
                elif replace == TodoItem.MODIFY:
                    print "Only the elements you add will be replaced.  So, for example,"
                    print "if you don't enter any projects the original projects will remain."
                else:
                    print "Elements you enter will be appended to the current task"
                entry = safeRawInput("Enter new details &gt;&gt;&gt;")
        if entry != "":
            if replace == TodoItem.APPEND:
                newItem = self.createItem(entry, password="unused") # we will discard the encrypted part on extend
            elif externalEditor:
                newItem = self.createItem(entry, password = key)
            else:
                newItem = self.createItem(entry)
                if newItem.hasHiddenTask():
                    clearScreen(self.sysCalls)
            if newItem.hasError():
                print "The task had errors:"
                print newItem.getError()
                print "Task ", index, " is unchanged."
            else:
                if newItem.hasHiddenTask() and replace == TodoItem.APPEND:
                    self.showError("It isn't possible to extend the encrypted part of a task.\nThis part is ignored.")
                self.todo[index].copy(newItem, replace)
                print "Task ", index, " has been changed."
                success = True
        else:
            print "Task ", index, " has not been touched."
    return success
</t>
<t tx="BIGZHU.20070802223007.104">def incTask(self):
    if self.currentTask &lt; len(self.todo) - 1:
        self.currentTask = self.currentTask + 1
</t>
<t tx="BIGZHU.20070802223007.105">def incTaskLoop(self):
    if self.currentTask &lt; len(self.todo) - 1:
        self.currentTask = self.currentTask + 1
    else:
        self.currentTask = 0
</t>
<t tx="BIGZHU.20070802223007.106">def decTask(self):
    if self.currentTask &gt; 0:
        self.currentTask = self.currentTask - 1
</t>
<t tx="BIGZHU.20070802223007.107">def decTaskLoop(self):
    if self.currentTask &gt; 0:
        self.currentTask = self.currentTask - 1
    else:
        self.currentTask = len(self.todo) - 1
</t>
<t tx="BIGZHU.20070802223007.108">def printItemTruncated(self, index, leader):
    if len(self.todo) &lt; 1:
        print leader, "no tasks"
    else:
        scrnline = leader + "[%02d] %s" % (index, self.todo[index].toStringSimple())
        if len(scrnline) &gt; gMaxLen:
            print scrnline[0:gMaxLen - 3] + "..."
        else:
            print scrnline
</t>
<t tx="BIGZHU.20070802223007.109">def printItem(self, index, colorType):
    if len(self.todo) &lt; 1:
        self.output("There are no tasks to be done.\n", 0)
        nlines = 1
    else:
        wrapper = WordWrapper(gMaxLen)
        scrnline = wrapper.wrap("[%02d] %s" % (index, self.todo[index].toStringSimple()))
        if colorType == "row0":
            style = "class=\"evenTask\""
        else:
            style = "class=\"oddTask\""
        self.output("&lt;div %s&gt;[%02d] %s&lt;/div&gt;\n" % (style, index, self.todo[index].toStringSimple()),
                gColor.code(colorType) + scrnline + gColor.code("normal") + "\n" )
        nlines = wrapper.getNLines()
    return nlines
</t>
<t tx="BIGZHU.20070802223007.110">def printItemVerbose(self, index):
    if len(self.todo) &lt; 1:
        print "There are no tasks to be done."
    else:
        self.showFilter()
        wrapper = WordWrapper(gMaxLen)
        scrnline = wrapper.wrap("[%02d] %s" % (index, self.todo[index].toStringVerbose()))
        print scrnline
</t>
<t tx="BIGZHU.20070802223007.111">def clearFilterArray(self, local):
    if local:
        self.localFilters = []
        self.localFilterText = ""
    else:
        self.globalFilters = []
        self.globalFilterText = ""
</t>
<t tx="BIGZHU.20070802223007.112">def setFilterArray(self, local, requiredFilter):
    filters = requiredFilter.split()
    if local:
        destination = self.localFilters
    else:
        destination = self.globalFilters
    destination[:] = []
    humanVersion = ""
    for word in filters:
        if word[0:1] == "-":
            invert = True
            word = word[1:]
        else:
            invert = False
        if word[0:2].upper() == ":D" and len(word) &gt; 2:
            filter = ":D" + TodoItem("").parseDate(word[2:].strip(), False)
        elif word[0:2].lower() == ":p":
            filter = globalPAbbr.expandProject(word)
        else:
            filter = globalAbbr.expandAction(word)
        if invert:
            filter = "-" + filter
        destination.append(filter)
        if humanVersion != "":
            humanVersion = humanVersion + " " + filter
        else:
            humanVersion = filter
    if local:
        for filter in self.globalFilters:
            destination.append(filter)
            if humanVersion != "":
                humanVersion = humanVersion + " " + filter
            else:
                humanVersion = filter
    if local:
        self.localFilterText = humanVersion
    else:
        self.globalFilterText = humanVersion
</t>
<t tx="BIGZHU.20070802223007.113">def isViewable(self, item):
    if len(self.globalFilters) == 0 and len(self.localFilters) == 0:
        return True
    overallView = True
    ored = False
    if len(self.localFilters) &gt; 0:
        filterArray = self.localFilters
    else:
        filterArray = self.globalFilters
    if "or" in filterArray or "OR" in filterArray:
        fast = False
    else:
        fast = True
    for filter in filterArray:
        if filter.upper() == "OR":
            ored = True
            continue
        view = False
        usePriority = False
        mustHave = False
        if filter[0:1] == "+":
            filter = filter[1:]
            mustHave = True
        if filter[0:1] == "-":
            invert = True
            filter = filter[1:]
        else:
            invert = False
        try:
            if filter[0:1] == "#":
                priority = int(filter[1:], 10)
                usePriority = True
        except ValueError:
            priority = 0
        if usePriority:
            if self.exactPriority:
                if item.hasPriority(priority):
                    view = True
            elif item.hasPriorityOrAbove(priority):
                view = True
        elif filter[0:2].upper() == ":D":
            if item.hasDate(filter[2:]):
                view = True
        elif filter[0:2].upper() == ":P":
            view = item.hasProject(filter)
        elif filter[0:1].upper() == "@":
            view = item.hasAction(filter)
        elif item.hasWord(filter):
            view = True
        if invert:
            view = (view != True)
        if ored:
            if view == True:
                overallView = True
                break
        else:
            if view == False:
                overallView = False
                if fast or mustHave:
                    break
        ored = False
    return overallView
</t>
<t tx="BIGZHU.20070802223007.114">def listByAction(self):
    index = SearchIndex()
    for item in self.todo:
        index.addCollection(item.getActions())
    index.sort()
    (n, value) = index.getFirstItem()
    print ruler
    self.showFilter()
    while n &gt;= 0:
        if not gColor.usingColor() and n &gt; 0:
            div = True
        else:
            div = False
        self.setFilterArray(True, "+" + value)
        self.printList(div, "&lt;H2 class=\"hAction\"&gt;" + value + "&lt;/H2&gt;\n", gColor.code("title") + "\n" + value + "\n" + gColor.code("title"))
        self.clearFilterArray(True)
        (n, value) = index.getNextItem(n)
    print ruler
</t>
<t tx="BIGZHU.20070802223007.115">def listByProject(self):
    index = SearchIndex()
    for item in self.todo:
        index.addCollection(item.getProjects())
    index.sort()
    (n, value) = index.getFirstItem()
    print ruler
    self.showFilter()
    while n &gt;= 0:
        if not gColor.usingColor() and n &gt; 0:
            div = True
        else:
            div = False
        self.setFilterArray(True, "+:p" + value)
        self.printList(div, "&lt;H2 class =\"hProject\"&gt;Project: " + value + "&lt;/H2&gt;\n", gColor.code("title") + "\nProject: " + value + "\n" + gColor.code("normal"))
        self.clearFilterArray(True)
        (n, value) = index.getNextItem(n)
    print ruler
</t>
<t tx="BIGZHU.20070802223007.116">def listByDate(self):
    index = SearchIndex()
    for item in self.todo:
        index.add(item.getDate())
    index.sort()
    (n, value) = index.getFirstItem()
    print ruler
    self.showFilter()
    while n &gt;= 0:
        if not gColor.usingColor() and n &gt; 0:
            div = True
        else:
            div = False
        self.setFilterArray(True, "+:D" + value)
        self.printList(div, "&lt;H2 class =\"hDate\"&gt;Date: " + value + "&lt;/H2&gt;\n", gColor.code("title") + "\nDate: " + value + "\n" + gColor.code("normal"))
        self.clearFilterArray(True)
        (n, value) = index.getNextItem(n)
    print ruler
</t>
<t tx="BIGZHU.20070802223007.117">def showFilter(self):
    if self.globalFilterText != "":
        self.output("&lt;H3 class =\"hFilter\"&gt;Filter = " + self.globalFilterText + "&lt;/H3&gt;\n",
        gColor.code("bold") + "Filter = " + self.globalFilterText + "\n" + gColor.code("normal"))
</t>
<t tx="BIGZHU.20070802223007.118">def showLocalFilter(self):
    if self.localFilterText != "":
        self.output("&lt;H3 class =\"hFilter\"&gt;Filter = " + self.localFilterText + "&lt;/H3&gt;\n",
        gColor.code("bold") + "Filter = " + self.localFilterText + "\n" + gColor.code("normal"))
</t>
<t tx="BIGZHU.20070802223007.119">def printList(self, div, outHtml, outStd):
    self.doPrintList(-1, div, outHtml, outStd)
</t>
<t tx="BIGZHU.20070802223007.120">def printShortList(self, line):
    count = 0
    try:
        count = int(line, 10)
    except ValueError:
        self.showError("Didn't understand the number of tasks you wanted listed.")
    self.doPrintList(count, False, "", "")
</t>
<t tx="BIGZHU.20070802223007.121">def doPrintList(self, limitItems, div, outHtml, outStd):
    n = 0
    displayed = 0
    count = 0
    color = "row0"
    first = True
    maxlines = 20
    if outHtml != "":
        self.outputHtml("&lt;div class=\"itemGroup\"&gt;\n")
    for item in self.todo:
        if self.isViewable(item):
            if first:
                if div:
                    print divider
                self.output(outHtml, outStd)
            if not gColor.usingColor() and not first:
                print divider
                count = count + 1
            count = count + self.printItem(n, color)
            first = False
            if color == "row0":
                color = "row1"
            else:
                color = "row0"
            displayed = displayed + 1
        n = n + 1
        if limitItems &gt;= 0 and displayed &gt;= limitItems:
            break
        if count &gt;= maxlines:
            if self.htmlFile == "":
                msg = safeRawInput("---press Enter for more.  Enter s to skip: ")
                if len(msg) &gt; 0 and msg.strip().upper()[0] == "S":
                    break;
            count = 0
    if outHtml != "":
        self.outputHtml("&lt;/div&gt;\n")
</t>
<t tx="BIGZHU.20070802223007.122">def printHelp(self, lines):
    ListViewer(24).show(lines,"!PAUSE!")
</t>
<t tx="BIGZHU.20070802223007.123">def splitFile(self, filename, dataOnly):
    inData = False
    inCode = False
    inCfg = False
    f = open(filename, 'r')
    line = f.readline()
    if line[0:2] == "#!":
        line = f.readline()
    while line != "":
        if line.find(magicTag + "DATA") == 0:
            inData = True
            inCode = False
            inCfg = False
        elif line.find(magicTag + "CONFIG") == 0:
            inData = False
            inCode = False
            inCfg = True
        elif line.find(magicTag + "CODE") == 0:
            inCode = True
            inData = False
            inCfg = False
            if dataOnly:
                break
        elif inCode:
            self.code.append(line)
        elif inCfg:
            self.processCfgLine(line)
        elif inData:
            line = line.strip()
            if len(line) &gt; 0 and line[0] == "#":
                line = line[1:].strip()
            if len(line) &gt; 0:
                newItem = self.createItem(line)
                newItem.getError()
                self.todo.append(newItem)

        line = f.readline()
    f.close()
</t>
<t tx="BIGZHU.20070802223007.124">def createItem(self, line, password = ""):
    item = TodoItem(line, password)
    return item
</t>
<t tx="BIGZHU.20070802223007.125">def outputHtml(self, html):
    if self.htmlFile != "":
        self.htmlFile.write(html)
</t>
<t tx="BIGZHU.20070802223007.126">def output(self, html, stdout):
    if self.htmlFile != "":
        #self.htmlFile.write(html.replace("\n", "&lt;br&gt;\n"))
        self.htmlFile.write(html)
    if stdout == 0:
        print html,
    else:
        print stdout,
</t>
<t tx="BIGZHU.20070802223007.127">def startHtml(self, title):
    htmlFilename = self.filename + ".html"
    try:
        self.htmlFile = open(htmlFilename, "w")
        self.htmlFile.write("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n")
        self.htmlFile.write("&lt;html&gt;\n&lt;head&gt;\n")
        self.htmlFile.write("&lt;style&gt;\n")
        self.htmlFile.write(".footer {text-align:center;}\n")
        self.htmlFile.write("&lt;/style&gt;\n")
        self.htmlFile.write("&lt;link rel=\"stylesheet\" href=\"ikog.css\" type=\"text/css\"&gt;\n")
        self.htmlFile.write("&lt;/head&gt;\n&lt;body&gt;\n")
        self.htmlFile.write("&lt;div class=\"header\"&gt;\n")
        self.htmlFile.write("&lt;H1 class=\"hTitle\"&gt;iKog Todo List&lt;/H1&gt;\n")
        self.htmlFile.write("&lt;H2 class=\"hSubTitle\"&gt;" + title + " printed " +  date.today().isoformat() + "&lt;/H1&gt;\n")
        self.htmlFile.write("&lt;/div&gt;\n")
        self.htmlFile.write("&lt;div class=\"taskArea\"&gt;\n")
    except Exception:
        print "Failed to create output file:", htmlFilename
        self.htmlFile = ""
</t>
<t tx="BIGZHU.20070802223007.128">def endHtml(self):
    name = self.htmlFile.name
    success = False
    try:
        self.htmlFile.write("&lt;/div&gt;\n")
        self.htmlFile.write("&lt;div class=\"footer\"&gt;\n")
        self.htmlFile.write("--- end of todo list ---&lt;br&gt;\n")
        self.htmlFile.write("Created using " + notice[0] + "\n&lt;br&gt;" + notice[1] + "&lt;br&gt;\n")
        self.htmlFile.write("&lt;/div&gt;\n")

        self.htmlFile.write("&lt;/body&gt;\n&lt;/html&gt;\n")
        self.htmlFile.close()
        self.htmlFile = ""
        print "HTML file " + name + " created."
        success = True
    except Exception, e:
        self.showError("Error writing to file. " + str(e))

    if success:
        try:
            safeName = os.path.abspath(name).replace("\\","/")
            safeName = "file://" + urllib.quote(safeName," /:")
            webbrowser.open(safeName)
        except Exception, e:
            self.showError("Unable to launch html output. " + str(e))
</t>
<t tx="BIGZHU.20070802223007.129">
class Abbreviations:
	@others
</t>
<t tx="BIGZHU.20070802223007.130">def __init__(self, project = False):
    self.default(project)
</t>
<t tx="BIGZHU.20070802223007.131">def default(self,project):
    if  project:
        self.abbrevs = {}
    else:
        self.abbrevs = {"@A":"@Anywhere","@C":"@Computer",
        "@D":"@Desk", "@E": "@Errands",
        "@H":"@Home", "@I":"@Internet","@L":"@Lunch", "@M":"@Meeting", "@N":"@Next",
        "@P":"@Phone", "@Pw":"@Password", "@S":"@Someday/Maybe",
        "@O":"@Other", "@W4":"@Waiting_For", "@W":"@Work"}
</t>
<t tx="BIGZHU.20070802223007.132">def setAbbreviations(self, abbr):
    self.abbrevs.update(abbr)
</t>
<t tx="BIGZHU.20070802223007.133">def addAbbreviation(self, key, word):
    self.abbrevs.update({key.title():word})
</t>
<t tx="BIGZHU.20070802223007.134">def removeAbbreviation(self, key):
    key = key.title()
    if self.abbrevs.has_key(key):
        del self.abbrevs[key]
        return True
    return False
</t>
<t tx="BIGZHU.20070802223007.135">def expandAction(self, action):
    if action[0:1] != "@":
        return action

    action = action.title()
    if self.abbrevs.has_key(action):
        return self.abbrevs[action]
    return action
</t>
<t tx="BIGZHU.20070802223007.136">def expandProject(self, project):
    if not project.lower().startswith(":p"):
        return project
    project = project.title()
    if self.abbrevs.has_key(project):
        return self.abbrevs[project]
    return project
</t>
<t tx="BIGZHU.20070802223007.137">def toString(self):
    return str(self.abbrevs)
</t>
<t tx="BIGZHU.20070802223007.138">def toStringVerbose(self):
    output = ""
    index = 0
    for key in self.abbrevs:
        output = output + key.ljust(5) + " = " + self.abbrevs[key].ljust(30)
        index = index + 1
        if index % 2 == 0:
            output = output + "\n"
    if index % 2 != 0:
        output = output + "\n"
    return output
</t>
<t tx="BIGZHU.20070802223007.139">
class SearchIndex:
	@others
</t>
<t tx="BIGZHU.20070802223007.140">def __init__(self):
    self.items = []
</t>
<t tx="BIGZHU.20070802223007.141">def add(self, ent):
    if ent != "" and not ent in self.items:
        self.items.append(ent)
</t>
<t tx="BIGZHU.20070802223007.142">def addCollection(self, collection):
    for ent in collection:
        if ent != "" and not ent in self.items:
            self.items.append(ent)
</t>
<t tx="BIGZHU.20070802223007.143">def sort(self):
    self.items.sort()
</t>
<t tx="BIGZHU.20070802223007.144">def getFirstItem(self):
    if len(self.items) &gt; 0:
        return (0, self.items[0])
    else:
        return (-1, "")
</t>
<t tx="BIGZHU.20070802223007.145">def getNextItem(self, count):
    count = count + 1
    if count &gt; len(self.items) - 1:
        return (-1, "")
    else:
        return (count, self.items[count])
        return
</t>
<t tx="BIGZHU.20070802223007.146">
class  TodoItem:
	&lt;&lt; class TodoItem declarations &gt;&gt;
	@others
</t>
<t tx="BIGZHU.20070802223007.147">ENCRYPTION_MARKER = "{}--xx"
REPLACE = 0
MODIFY = 1
APPEND = 2
NOT_DUE_PRIORITY = 0
DEFAULT_PRIORITY = 5
OVERDUE_PRIORITY = 11
MEETING_PRIORITY = 10
</t>
<t tx="BIGZHU.20070802223007.148">def __init__(self,line, password = ""):
    self.actions = []
    self.task = ""
    self.hiddenTask = ""
    self.projects = []
    self.priority = -1
    self.when = ""
    self.created = date.today().isoformat()
    self.error = ""
    self.autoAction = False
    self.autoProject = False
    self.nullDate = False
    self.parse(line, password)
</t>
<t tx="BIGZHU.20070802223007.149">def makeSafeDate(self, year, month, day):
    done = False
    while not done:
        if day &lt; 1:
            done = True
        else:
            try:
                newDate = date(year, month, day)
                done = True
            except ValueError:
                day = day - 1
                newDate = ""
    return newDate
</t>
<t tx="BIGZHU.20070802223007.150">def parseDate(self, dateStr, quiet):
    dateStr = dateStr.replace("/","-")
    dateStr = dateStr.replace(":","-")
    entry = dateStr.split("-")
    n = len(entry)
    if n &lt; 1 or n &gt; 3:
        fail = True
    elif dateStr == "0":
        self.nullDate = True
        return ""
    else:
        try:
            now = date.today()
            if dateStr[0:1] == "+":
                days = int(dateStr[1:].strip(), 10)
                when = now + timedelta(days)
            else:
                if n == 3:
                    year = int(entry[0], 10)
                    month = int(entry[1], 10)
                    day = int(entry[2], 10)
                elif n == 2:
                    year = now.year
                    month = int(entry[0], 10)
                    day = int(entry[1], 10)
                else:
                    year = now.year
                    month = now.month
                    day = int(entry[0], 10)
                    if day &lt; now.day:
                        month = month + 1
                    if month &gt; 12:
                        month = 1
                        year = year + 1
                if year &lt; 1000:
                    year = year + 2000
                when = self.makeSafeDate(year, month, day)
            fail = False
            self.nullDate = False
        except ValueError:
            fail = True
        except:
            fail = True
    if fail:
        self.addError("Could not decode the date. Use :dYYYY/MM/DD")
        return ""
    else:
        return when.isoformat()
</t>
<t tx="BIGZHU.20070802223007.151">def parse(self, line, password):
    self.error = ""
    words = line.split(" ")
    taskToHide = ""
    encrypt = ""
    start = 0
    ecmLen = len(self.ENCRYPTION_MARKER)
    for word in words[start:]:
        wordUC = word.strip().upper()
        if len(word) &gt; 0:
            if encrypt != "":
                taskToHide = taskToHide + word.strip() + " "
            elif word[0:ecmLen] == self.ENCRYPTION_MARKER:
                self.hiddenTask = word[ecmLen:]
            elif wordUC.startswith("&lt;PRIVATE&gt;") or wordUC.startswith("&lt;SECRET&gt;") or wordUC.startswith("&lt;S&gt;") or wordUC.startswith("&lt;P&gt;"):
                encrypt = wordUC[1]
                try:
                    pos = word.index("&gt;")
                    taskToHide = taskToHide + word[pos + 1:].strip() + " "
                except ValueError:
                    pass
            elif word[0] == "@" and len(word) &gt; 1:
                if wordUC == "@DATE":
                    self.addError("@Date contexts should not be entered. Use :dYYYY-MM-DD")
                else:
                    act = globalAbbr.expandAction(word.strip())
                    if not act in self.actions:
                        self.actions.append(act)
            elif word[0:1] == "#" and len(word) &gt; 1 and self.priority == -1:
                try:
                    self.priority = int(word[1:].strip(), 10)
                    if self.priority &lt; 1:
                        self.priority = 0
                    elif self.priority &gt; 10:
                        self.priority = 10
                except ValueError:
                    self.addError("Did not understand priority.")
                    self.priority = -1
            elif wordUC[0:2] == ":P" and len(word) &gt; 2:
                proj = globalPAbbr.expandProject(word.strip())[2:].title()
                if not proj in self.projects:
                    self.projects.append(proj)
            elif wordUC[0:8] == ":CREATED" and len(word) &gt; 8:
                self.created = word[8:].strip()
            elif wordUC[0:2] == ":D" and len(word) &gt; 2:
                self.when = self.parseDate(word[2:].strip(), False)
            else:
                self.task = self.task + word.strip() + " "
    if taskToHide != "":
        ec = Encryptor()
        if encrypt == "S":
            if ec.setType(ec.TYPE_AES) != ec.TYPE_AES:
                self.addError("AES encryption is not available.")
                taskToHide = ""
        else:
            ec.setType(ec.TYPE_OBSCURED)
    if taskToHide != "":
        if password == "":
            self.hiddenTask = ec.enterKeyAndEncrypt(taskToHide)
        else:
            ec.setKey(password)
            self.hiddenTask = ec.encrypt(taskToHide)

    if len(self.actions) == 0:
        self.actions.append("@Anywhere")
    self.autoAction = True
    if len(self.projects) == 0:
        self.projects.append("None")
    self.autoProject = True
</t>
<t tx="BIGZHU.20070802223007.152">def addError(self, err):
    if len(self.error) &gt; 0:
        self.error = self.error + "\n"
    self.error = self.error + err
</t>
<t tx="BIGZHU.20070802223007.153">def hasError(self):
    return self.error != ""
</t>
<t tx="BIGZHU.20070802223007.154">def getError(self):
    tmp = self.error
    self.error = ""
    return tmp
</t>
<t tx="BIGZHU.20070802223007.155">def hasWord(self, word):
    return (self.task.upper().find(word.upper()) &gt;= 0)
</t>
<t tx="BIGZHU.20070802223007.156">def hasAction(self, loc):
    if self.when != "" and loc.upper() == "@DATE":
        return True
    else:
        return loc.title() in self.actions
</t>
<t tx="BIGZHU.20070802223007.157">def copy(self, todoItem, replace):
    if replace == TodoItem.REPLACE or len(todoItem.task.strip()) &gt; 0:
        if replace == TodoItem.APPEND:
            self.task = self.task + " ..." + todoItem.task
        else:
            self.task = todoItem.task
    if replace == TodoItem.REPLACE or todoItem.autoAction == False:
        if replace != TodoItem.APPEND:
            self.actions = []
        for loc in todoItem.actions:
            if not loc in self.actions:
                self.actions.append(loc)
    if replace == TodoItem.REPLACE or todoItem.autoProject == False:
        if replace != TodoItem.APPEND:
            self.projects = []
        for proj in todoItem.projects:
            if not proj in self.projects:
                self.projects.append(proj)
    if replace == TodoItem.REPLACE or (todoItem.when != "" or todoItem.nullDate == True):
        self.when = todoItem.when
    if todoItem.priority &gt;= 0:
        self.priority = todoItem.priority

    if replace == TodoItem.REPLACE or len(todoItem.hiddenTask.strip()) &gt; 0:
        if replace == TodoItem.APPEND:
            pass
        else:
            self.hiddenTask = todoItem.hiddenTask
</t>
<t tx="BIGZHU.20070802223007.158">def hasHiddenTask(self):
    return self.hiddenTask != ""
</t>
<t tx="BIGZHU.20070802223007.159">def hasTask(self):
    return len(self.task.strip()) &gt; 0
</t>
<t tx="BIGZHU.20070802223007.160">def hasProject(self, proj):
    if proj[0:2].upper() == ":P":
        proj = proj[2:]
    return proj.title() in self.projects
</t>
<t tx="BIGZHU.20070802223007.161">def hasDate(self, dt):
    dt = self.parseDate(dt, True)
    if dt == "":
        return False
    else:
        return self.when == dt
</t>
<t tx="BIGZHU.20070802223007.162">def hasPriorityOrAbove(self, priority):
    return (self.getEffectivePriority() &gt;= priority)
</t>
<t tx="BIGZHU.20070802223007.163">def hasPriority(self, priority):
    return (self.getEffectivePriority() == priority)
</t>
<t tx="BIGZHU.20070802223007.164">def getHiddenTask(self):
    return self.hiddenTask
</t>
<t tx="BIGZHU.20070802223007.165">def getTask(self):
    return self.task
</t>
<t tx="BIGZHU.20070802223007.166">def getActions(self):
    if self.when == "":
        return self.actions
    else:
        return self.actions + ["@Date"]
</t>
<t tx="BIGZHU.20070802223007.167">def getProjects(self):
    return self.projects
</t>
<t tx="BIGZHU.20070802223007.168">def getDate(self):
    return self.when
</t>
<t tx="BIGZHU.20070802223007.169">def getPriority(self):
    if self.priority &lt; 0:
        return self.DEFAULT_PRIORITY
    else:
        return self.priority
</t>
<t tx="BIGZHU.20070802223007.170">def getEffectivePriority(self):
    userP = self.getPriority()
    if self.when != "":
        if self.when &lt;= date.today().isoformat():
            userP = self.OVERDUE_PRIORITY + userP
            if self.hasAction("@Meeting"):
                userP = userP + self.MEETING_PRIORITY
        else:
            userP = self.NOT_DUE_PRIORITY
    return userP
</t>
<t tx="BIGZHU.20070802223007.171">def toString(self):
    entry = "#"
    entry = entry + " " + self.task
    for action in self.actions:
        entry = entry + " " + action
    for project in self.projects:
        entry = entry + " :p" + project
    entry = entry + " :created" + self.created
    if self.when != "":
        entry = entry + " :d" + self.when
    if self.priority &gt;= 0:
        entry = entry + " #" + str(self.priority)
    if self.hiddenTask != "":
        entry = entry + " " + self.ENCRYPTION_MARKER + self.hiddenTask
    return entry
</t>
<t tx="BIGZHU.20070802223007.172">def toStringEditable(self, includeHidden = False):
    password = ""
    entry = ""
    if self.when != "":
        entry = entry + ":d" + self.when + " "
    entry = entry + "%s #%d" % (self.task, self.getPriority())
    if len(self.actions) &gt; 0:
        for action in self.actions:
            entry = entry + " " + action
    if len(self.projects) &gt; 0:
        for project in self.projects:
            # skip the none tag
            if project != "None":
                entry = entry + " :p" + project
    if self.hiddenTask != "" and includeHidden:
        ec = Encryptor()
        entry = entry + " &lt;" + Encryptor().getSecurityClass(self.hiddenTask)[0:1] + "&gt;"
        entry = entry + ec.enterKeyAndDecrypt(self.hiddenTask)
        password = ec.getKey()
    return (password, entry.strip())
</t>
<t tx="BIGZHU.20070802223007.173">def toStringSimple(self):
    entry = ""
    if self.when != "":
        entry = entry + "@Date " + self.when + " "
    entry = entry + "%s #%d" % (self.task, self.getPriority())
    if self.hiddenTask != "":
        entry = entry + " &lt;*** " + Encryptor().getSecurityClass(self.hiddenTask) + " ***&gt; "
    if len(self.actions) &gt; 0:
        for action in self.actions:
            entry = entry + " " + action
    if len(self.projects) &gt; 0:
        first = True
        for project in self.projects:
            # skip the none tag
            if project != "None":
                if first:
                    entry = entry + " Projects: " + project
                    first = False
                else:
                    entry = entry + ", " + project
    entry = entry + " [" + self.created + "]"
    return entry
</t>
<t tx="BIGZHU.20070802223007.174">def toStringVerbose(self):
    entry = gColor.code("title") + self.task
    if self.hiddenTask != "":
        entry = entry + " &lt;*** " + Encryptor().getSecurityClass(self.hiddenTask) + " ***&gt; "
    entry = entry + gColor.code("bold") + "\nPriority: %02d" % (self.getPriority())
    if len(self.actions) or self.when != "" &gt; 0:
        entry = entry + gColor.code("heading") + "\nContext: "
        if self.when != "":
            entry = entry + gColor.code("important") + "@Date " + self.when
        entry = entry + gColor.code("normal")
        for action in self.actions:
            entry = entry + " " + action;
    if len(self.projects) &gt; 0:
        first = True
        for project in self.projects:
            if project != "None":
                if first:
                    entry = entry + gColor.code("heading") + "\nProjects: " + gColor.code("normal");
                    entry = entry + project
                    first = False
                else:
                    entry = entry + ", " + project
    entry = entry + gColor.code("normal") + "\nCreated: [" + self.created + "]"
    return entry
</t>
<t tx="BIGZHU.20070806144525">@language python
"""打包生成exe文件,执行 toexe.py py2exe"""
from distutils.core import setup
import py2exe
import os
file = os.getcwd()+"\\get_cmfu.py"
setup(console=[file])</t>
</tnodes>
</leo_file>
